<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Arroy (Approximate Rearest Reighbors Oh Yeah) is a Rust library with the interface of the Annoy Python library to search for vectors in space that are close to a given query vector. It is based on LMDB, a memory-mapped key-value store, so many processes may share the same data and atomically modify the vectors."><title>arroy - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="arroy" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0 (17067e9ac 2025-05-09)" data-channel="1.87.0" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../static.files/storage-82c7156e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/meilisearch/arroy/main/assets/arroy-electric-clusters.ico?raw=true"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../arroy/index.html"><img src="https://raw.githubusercontent.com/meilisearch/arroy/main/assets/arroy-electric-clusters-logo.png?raw=true" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../arroy/index.html"><img src="https://raw.githubusercontent.com/meilisearch/arroy/main/assets/arroy-electric-clusters-logo.png?raw=true" alt="logo"></a><h2><a href="../arroy/index.html">arroy</a><span class="version">0.5.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#examples" title="Examples">Examples</a></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>arroy</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/arroy/lib.rs.html#1-152">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Arroy (<a href="https://en.wikipedia.org/wiki/Nearest_neighbor_search#Approximate_nearest_neighbor">Approximate Rearest Reighbors</a> Oh Yeah) is a Rust library with the interface of the <a href="https://github.com/spotify/annoy/#full-python-api">Annoy Python library</a> to search for vectors in space that are close to a given query vector. It is based on LMDB, a memory-mapped key-value store, so many processes may share the same data and atomically modify the vectors.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<p>Open an LMDB database, store some vectors in it and query the top 20 nearest items from the first vector. This is the most trivial way to use arroy and it’s fairly easy. Just do not forget to <a href="struct.Writer.html#method.build" title="method arroy::Writer::build"><code>Writer::build</code></a> and <a href="../heed/txn/struct.RwTxn.html#method.commit" title="method heed::txn::RwTxn::commit"><code>heed::RwTxn::commit</code></a> when you are done inserting your items.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::num::NonZeroUsize;

<span class="kw">use </span>arroy::distances::Euclidean;
<span class="kw">use </span>arroy::{Database <span class="kw">as </span>ArroyDatabase, Writer, Reader};
<span class="kw">use </span>rand::rngs::StdRng;
<span class="kw">use </span>rand::{Rng, SeedableRng};

<span class="doccomment">/// That's the 200MiB size limit we allow LMDB to grow.
</span><span class="kw">const </span>TWENTY_HUNDRED_MIB: usize = <span class="number">2 </span>* <span class="number">1024 </span>* <span class="number">1024 </span>* <span class="number">1024</span>;

<span class="kw">let </span>dir = tempfile::tempdir()<span class="question-mark">?</span>;
<span class="kw">let </span>env = <span class="kw">unsafe </span>{ heed::EnvOpenOptions::new().map_size(TWENTY_HUNDRED_MIB).open(dir.path()) }<span class="question-mark">?</span>;

<span class="comment">// we will open the default LMDB unnamed database
</span><span class="kw">let </span><span class="kw-2">mut </span>wtxn = env.write_txn()<span class="question-mark">?</span>;
<span class="kw">let </span>db: ArroyDatabase&lt;Euclidean&gt; = env.create_database(<span class="kw-2">&amp;mut </span>wtxn, <span class="prelude-val">None</span>)<span class="question-mark">?</span>;

<span class="comment">// Now we can give it to our arroy writer
</span><span class="kw">let </span>index = <span class="number">0</span>;
<span class="kw">let </span>dimensions = <span class="number">5</span>;
<span class="kw">let </span>writer = Writer::&lt;Euclidean&gt;::new(db, index, dimensions);

<span class="comment">// let's write some vectors
</span>writer.add_item(<span class="kw-2">&amp;mut </span>wtxn, <span class="number">0</span>,    <span class="kw-2">&amp;</span>[<span class="number">0.8</span>,  <span class="number">0.49</span>, <span class="number">0.27</span>, <span class="number">0.76</span>, <span class="number">0.94</span>])<span class="question-mark">?</span>;
writer.add_item(<span class="kw-2">&amp;mut </span>wtxn, <span class="number">1</span>,    <span class="kw-2">&amp;</span>[<span class="number">0.66</span>, <span class="number">0.86</span>, <span class="number">0.42</span>, <span class="number">0.4</span>,  <span class="number">0.31</span>])<span class="question-mark">?</span>;
writer.add_item(<span class="kw-2">&amp;mut </span>wtxn, <span class="number">2</span>,    <span class="kw-2">&amp;</span>[<span class="number">0.5</span>,  <span class="number">0.95</span>, <span class="number">0.7</span>,  <span class="number">0.51</span>, <span class="number">0.03</span>])<span class="question-mark">?</span>;
writer.add_item(<span class="kw-2">&amp;mut </span>wtxn, <span class="number">100</span>,  <span class="kw-2">&amp;</span>[<span class="number">0.52</span>, <span class="number">0.33</span>, <span class="number">0.65</span>, <span class="number">0.23</span>, <span class="number">0.44</span>])<span class="question-mark">?</span>;
writer.add_item(<span class="kw-2">&amp;mut </span>wtxn, <span class="number">1000</span>, <span class="kw-2">&amp;</span>[<span class="number">0.18</span>, <span class="number">0.43</span>, <span class="number">0.48</span>, <span class="number">0.81</span>, <span class="number">0.29</span>])<span class="question-mark">?</span>;

<span class="comment">// You can specify the number of trees to use or specify None.
</span><span class="kw">let </span><span class="kw-2">mut </span>rng = StdRng::seed_from_u64(<span class="number">42</span>);
writer.builder(<span class="kw-2">&amp;mut </span>rng).build(<span class="kw-2">&amp;mut </span>wtxn)<span class="question-mark">?</span>;

<span class="comment">// By committing, other readers can query the database in parallel.
</span>wtxn.commit()<span class="question-mark">?</span>;

<span class="kw">let </span><span class="kw-2">mut </span>rtxn = env.read_txn()<span class="question-mark">?</span>;
<span class="kw">let </span>reader = Reader::&lt;Euclidean&gt;::open(<span class="kw-2">&amp;</span>rtxn, index, db)<span class="question-mark">?</span>;
<span class="kw">let </span>n_results = <span class="number">20</span>;

<span class="kw">let </span><span class="kw-2">mut </span>query = reader.nns(n_results);

<span class="comment">// You can increase the quality of the results by forcing arroy to search into more nodes.
// This multiplier is arbitrary but basically the higher, the better the results, the slower the query.
</span><span class="kw">let </span>is_precise = <span class="bool-val">true</span>;
<span class="kw">if </span>is_precise {
    query.search_k(NonZeroUsize::new(n_results * reader.n_trees() * <span class="number">15</span>).unwrap());
}

<span class="comment">// Similar searching can be achieved by requesting the nearest neighbors of a given item.
</span><span class="kw">let </span>item_id = <span class="number">0</span>;
<span class="kw">let </span>arroy_results = query.by_item(<span class="kw-2">&amp;</span>rtxn, item_id)<span class="question-mark">?</span>.unwrap();</code></pre></div>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="distances/index.html" title="mod arroy::distances">distances</a></dt><dd>The set of distances implementing the <a href="trait.Distance.html" title="trait arroy::Distance"><code>Distance</code></a> and supported by arroy.</dd><dt><a class="mod" href="internals/index.html" title="mod arroy::internals">internals</a></dt><dd>The set of types used by the <a href="trait.Distance.html" title="trait arroy::Distance"><code>Distance</code></a> trait.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.ArroyBuilder.html" title="struct arroy::ArroyBuilder">Arroy<wbr>Builder</a></dt><dd>The options available when building the arroy database.</dd><dt><a class="struct" href="struct.QueryBuilder.html" title="struct arroy::QueryBuilder">Query<wbr>Builder</a></dt><dd>Options used to make a query against an arroy <a href="struct.Reader.html" title="struct arroy::Reader"><code>Reader</code></a>.</dd><dt><a class="struct" href="struct.Reader.html" title="struct arroy::Reader">Reader</a></dt><dd>A reader over the arroy trees and user items.</dd><dt><a class="struct" href="struct.Stats.html" title="struct arroy::Stats">Stats</a></dt><dd>The different stats of an arroy database.</dd><dt><a class="struct" href="struct.TreeStats.html" title="struct arroy::TreeStats">Tree<wbr>Stats</a></dt><dd>The different stats of a tree in an arroy database.</dd><dt><a class="struct" href="struct.Writer.html" title="struct arroy::Writer">Writer</a></dt><dd>A writer to store new items, remove existing ones,
and build the search tree to query the nearest
neighbors to items or vectors.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Error.html" title="enum arroy::Error">Error</a></dt><dd>The different set of errors that arroy can encounter.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Distance.html" title="trait arroy::Distance">Distance</a></dt><dd>A trait used by arroy to compute the distances,
compute the split planes, and normalize user vectors.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.Database.html" title="type arroy::Database">Database</a></dt><dd>The database required by arroy for reading or writing operations.</dd><dt><a class="type" href="type.ItemId.html" title="type arroy::ItemId">ItemId</a></dt><dd>An identifier for the items stored in the database.</dd><dt><a class="type" href="type.Result.html" title="type arroy::Result">Result</a></dt><dd>A custom Result type that is returning an arroy error by default.</dd></dl></section></div></main></body></html>