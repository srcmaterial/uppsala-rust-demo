<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="lopdf"><title>lopdf - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="lopdf" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0 (17067e9ac 2025-05-09)" data-channel="1.87.0" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../static.files/storage-82c7156e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../lopdf/index.html">lopdf</a><span class="version">0.35.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#lopdf" title="lopdf">lopdf</a><ul><li><a href="#example-code" title="Example Code">Example Code</a></li><li><a href="#faq" title="FAQ">FAQ</a></li></ul></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>lopdf</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/lopdf/lib.rs.html#1-48">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="lopdf"><a class="doc-anchor" href="#lopdf">ยง</a>lopdf</h2>
<p><a href="https://crates.io/crates/lopdf"><img src="https://img.shields.io/crates/v/lopdf.svg" alt="Crates.io" /></a>
<a href="https://github.com/J-F-Liu/lopdf/actions/workflows/ci.yml"><img src="https://github.com/J-F-Liu/lopdf/actions/workflows/ci.yml/badge.svg" alt="CI" /></a>
<a href="https://docs.rs/lopdf"><img src="https://docs.rs/lopdf/badge.svg" alt="Docs" /></a></p>
<p>A Rust library for PDF document manipulation.</p>
<p>A useful reference for understanding the PDF file format and the
eventual usage of this library is the
<a href="https://opensource.adobe.com/dc-acrobat-sdk-docs/pdfstandards/PDF32000_2008.pdf">PDF 1.7 Reference Document</a>.
The PDF 2.0 specification is available <a href="https://www.pdfa.org/announcing-no-cost-access-to-iso-32000-2-pdf-2-0/">here</a>.</p>
<h3 id="example-code"><a class="doc-anchor" href="#example-code">ยง</a>Example Code</h3>
<ul>
<li>Create PDF document</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lopdf::dictionary;
<span class="kw">use </span>lopdf::{Document, Object, Stream};
<span class="kw">use </span>lopdf::content::{Content, Operation};

<span class="comment">// `with_version` specifes the PDF version this document complies with.
</span><span class="kw">let </span><span class="kw-2">mut </span>doc = Document::with_version(<span class="string">"1.5"</span>);
<span class="comment">// Object IDs are used for cross referencing in PDF documents.
// `lopdf` helps keep track of them for us. They are simple integers.
// Calls to `doc.new_object_id` and `doc.add_object` return an object ID.

// "Pages" is the root node of the page tree.
</span><span class="kw">let </span>pages_id = doc.new_object_id();

<span class="comment">// Fonts are dictionaries. The "Type", "Subtype" and "BaseFont" tags
// are straight out of the PDF spec.
//
// The dictionary macro is a helper that allows complex
// key-value relationships to be represented in a simpler
// visual manner, similar to a match statement.
// A dictionary is implemented as an IndexMap of Vec&lt;u8&gt;, and Object
</span><span class="kw">let </span>font_id = doc.add_object(<span class="macro">dictionary!</span> {
    <span class="comment">// type of dictionary
    </span><span class="string">"Type" </span>=&gt; <span class="string">"Font"</span>,
    <span class="comment">// type of font, type1 is simple postscript font
    </span><span class="string">"Subtype" </span>=&gt; <span class="string">"Type1"</span>,
    <span class="comment">// basefont is postscript name of font for type1 font.
    // See PDF reference document for more details
    </span><span class="string">"BaseFont" </span>=&gt; <span class="string">"Courier"</span>,
});

<span class="comment">// Font dictionaries need to be added into resource
// dictionaries in order to be used.
// Resource dictionaries can contain more than just fonts,
// but normally just contains fonts.
// Only one resource dictionary is allowed per page tree root.
</span><span class="kw">let </span>resources_id = doc.add_object(<span class="macro">dictionary!</span> {
    <span class="comment">// Fonts are actually triplely nested dictionaries. Fun!
    </span><span class="string">"Font" </span>=&gt; <span class="macro">dictionary!</span> {
        <span class="comment">// F1 is the font name used when writing text.
        // It must be unique in the document. It does not
        // have to be F1
        </span><span class="string">"F1" </span>=&gt; font_id,
    },
});

<span class="comment">// `Content` is a wrapper struct around an operations struct that contains
// a vector of operations. The operations struct contains a vector of
// that match up with a particular PDF operator and operands.
// Refer to the PDF spec for more details on the operators and operands
// Note, the operators and operands are specified in a reverse order
// from how they actually appear in the PDF file itself.
</span><span class="kw">let </span>content = Content {
    operations: <span class="macro">vec!</span>[
        <span class="comment">// BT begins a text element. It takes no operands.
        </span>Operation::new(<span class="string">"BT"</span>, <span class="macro">vec!</span>[]),
        <span class="comment">// Tf specifies the font and font size.
        // Font scaling is complicated in PDFs.
        // Refer to the spec for more info.
        // The `into()` methods convert the types into
        // an enum that represents the basic object types in PDF documents.
        </span>Operation::new(<span class="string">"Tf"</span>, <span class="macro">vec!</span>[<span class="string">"F1"</span>.into(), <span class="number">48</span>.into()]),
        <span class="comment">// Td adjusts the translation components of the text matrix.
        // When used for the first time after BT, it sets the initial
        // text position on the page.
        // Note: PDF documents have Y=0 at the bottom. Thus 600 to print text near the top.
        </span>Operation::new(<span class="string">"Td"</span>, <span class="macro">vec!</span>[<span class="number">100</span>.into(), <span class="number">600</span>.into()]),
        <span class="comment">// Tj prints a string literal to the page. By default, this is black text that is
        // filled in. There are other operators that can produce various textual effects and
        // colors
        </span>Operation::new(<span class="string">"Tj"</span>, <span class="macro">vec!</span>[Object::string_literal(<span class="string">"Hello World!"</span>)]),
        <span class="comment">// ET ends the text element.
        </span>Operation::new(<span class="string">"ET"</span>, <span class="macro">vec!</span>[]),
    ],
};

<span class="comment">// Streams are a dictionary followed by a (possibly encoded) sequence of bytes.
// What that sequence of bytes represents, depends on the context.
// The stream dictionary is set internally by lopdf and normally doesn't
// need to be manually manipulated. It contains keys such as
// Length, Filter, DecodeParams, etc.
</span><span class="kw">let </span>content_id = doc.add_object(Stream::new(<span class="macro">dictionary!</span> {}, content.encode().unwrap()));

<span class="comment">// Page is a dictionary that represents one page of a PDF file.
// Its required fields are "Type", "Parent" and "Contents".
</span><span class="kw">let </span>page_id = doc.add_object(<span class="macro">dictionary!</span> {
    <span class="string">"Type" </span>=&gt; <span class="string">"Page"</span>,
    <span class="string">"Parent" </span>=&gt; pages_id,
    <span class="string">"Contents" </span>=&gt; content_id,
});

<span class="comment">// Again, "Pages" is the root of the page tree. The ID was already created
// at the top of the page, since we needed it to assign to the parent element
// of the page dictionary.
//
// These are just the basic requirements for a page tree root object.
// There are also many additional entries that can be added to the dictionary,
// if needed. Some of these can also be defined on the page dictionary itself,
// and not inherited from the page tree root.
</span><span class="kw">let </span>pages = <span class="macro">dictionary!</span> {
    <span class="comment">// Type of dictionary
    </span><span class="string">"Type" </span>=&gt; <span class="string">"Pages"</span>,
    <span class="comment">// Vector of page IDs in document. Normally would contain more than one ID
    // and be produced using a loop of some kind.
    </span><span class="string">"Kids" </span>=&gt; <span class="macro">vec!</span>[page_id.into()],
    <span class="comment">// Page count
    </span><span class="string">"Count" </span>=&gt; <span class="number">1</span>,
    <span class="comment">// ID of resources dictionary, defined earlier
    </span><span class="string">"Resources" </span>=&gt; resources_id,
    <span class="comment">// A rectangle that defines the boundaries of the physical or digital media.
    // This is the "page size".
    </span><span class="string">"MediaBox" </span>=&gt; <span class="macro">vec!</span>[<span class="number">0</span>.into(), <span class="number">0</span>.into(), <span class="number">595</span>.into(), <span class="number">842</span>.into()],
};

<span class="comment">// Using `insert()` here, instead of `add_object()` since the ID is already known.
</span>doc.objects.insert(pages_id, Object::Dictionary(pages));

<span class="comment">// Creating document catalog.
// There are many more entries allowed in the catalog dictionary.
</span><span class="kw">let </span>catalog_id = doc.add_object(<span class="macro">dictionary!</span> {
    <span class="string">"Type" </span>=&gt; <span class="string">"Catalog"</span>,
    <span class="string">"Pages" </span>=&gt; pages_id,
});

<span class="comment">// The "Root" key in trailer is set to the ID of the document catalog,
// the remainder of the trailer is set during `doc.save()`.
</span>doc.trailer.set(<span class="string">"Root"</span>, catalog_id);
doc.compress();

<span class="comment">// Store file in current working directory.
// Note: Line is excluded when running tests
</span><span class="kw">if </span><span class="bool-val">false </span>{
    doc.save(<span class="string">"example.pdf"</span>).unwrap();
}</code></pre></div>
<ul>
<li>Merge PDF documents</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lopdf::dictionary;

<span class="kw">use </span>std::collections::BTreeMap;

<span class="kw">use </span>lopdf::content::{Content, Operation};
<span class="kw">use </span>lopdf::{Document, Object, ObjectId, Stream, Bookmark};

<span class="kw">pub fn </span>generate_fake_document() -&gt; Document {
    <span class="kw">let </span><span class="kw-2">mut </span>doc = Document::with_version(<span class="string">"1.5"</span>);
    <span class="kw">let </span>pages_id = doc.new_object_id();
    <span class="kw">let </span>font_id = doc.add_object(<span class="macro">dictionary!</span> {
        <span class="string">"Type" </span>=&gt; <span class="string">"Font"</span>,
        <span class="string">"Subtype" </span>=&gt; <span class="string">"Type1"</span>,
        <span class="string">"BaseFont" </span>=&gt; <span class="string">"Courier"</span>,
    });
    <span class="kw">let </span>resources_id = doc.add_object(<span class="macro">dictionary!</span> {
        <span class="string">"Font" </span>=&gt; <span class="macro">dictionary!</span> {
            <span class="string">"F1" </span>=&gt; font_id,
        },
    });
    <span class="kw">let </span>content = Content {
        operations: <span class="macro">vec!</span>[
            Operation::new(<span class="string">"BT"</span>, <span class="macro">vec!</span>[]),
            Operation::new(<span class="string">"Tf"</span>, <span class="macro">vec!</span>[<span class="string">"F1"</span>.into(), <span class="number">48</span>.into()]),
            Operation::new(<span class="string">"Td"</span>, <span class="macro">vec!</span>[<span class="number">100</span>.into(), <span class="number">600</span>.into()]),
            Operation::new(<span class="string">"Tj"</span>, <span class="macro">vec!</span>[Object::string_literal(<span class="string">"Hello World!"</span>)]),
            Operation::new(<span class="string">"ET"</span>, <span class="macro">vec!</span>[]),
        ],
    };
    <span class="kw">let </span>content_id = doc.add_object(Stream::new(<span class="macro">dictionary!</span> {}, content.encode().unwrap()));
    <span class="kw">let </span>page_id = doc.add_object(<span class="macro">dictionary!</span> {
        <span class="string">"Type" </span>=&gt; <span class="string">"Page"</span>,
        <span class="string">"Parent" </span>=&gt; pages_id,
        <span class="string">"Contents" </span>=&gt; content_id,
        <span class="string">"Resources" </span>=&gt; resources_id,
        <span class="string">"MediaBox" </span>=&gt; <span class="macro">vec!</span>[<span class="number">0</span>.into(), <span class="number">0</span>.into(), <span class="number">595</span>.into(), <span class="number">842</span>.into()],
    });
    <span class="kw">let </span>pages = <span class="macro">dictionary!</span> {
        <span class="string">"Type" </span>=&gt; <span class="string">"Pages"</span>,
        <span class="string">"Kids" </span>=&gt; <span class="macro">vec!</span>[page_id.into()],
        <span class="string">"Count" </span>=&gt; <span class="number">1</span>,
    };
    doc.objects.insert(pages_id, Object::Dictionary(pages));
    <span class="kw">let </span>catalog_id = doc.add_object(<span class="macro">dictionary!</span> {
        <span class="string">"Type" </span>=&gt; <span class="string">"Catalog"</span>,
        <span class="string">"Pages" </span>=&gt; pages_id,
    });
    doc.trailer.set(<span class="string">"Root"</span>, catalog_id);

    doc
}

<span class="kw">fn </span>main() -&gt; std::io::Result&lt;()&gt; {
    <span class="comment">// Generate a stack of Documents to merge.
    </span><span class="kw">let </span>documents = <span class="macro">vec!</span>[
        generate_fake_document(),
        generate_fake_document(),
        generate_fake_document(),
        generate_fake_document(),
    ];

    <span class="comment">// Define a starting `max_id` (will be used as start index for object_ids).
    </span><span class="kw">let </span><span class="kw-2">mut </span>max_id = <span class="number">1</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>pagenum = <span class="number">1</span>;
    <span class="comment">// Collect all Documents Objects grouped by a map
    </span><span class="kw">let </span><span class="kw-2">mut </span>documents_pages = BTreeMap::new();
    <span class="kw">let </span><span class="kw-2">mut </span>documents_objects = BTreeMap::new();
    <span class="kw">let </span><span class="kw-2">mut </span>document = Document::with_version(<span class="string">"1.5"</span>);

    <span class="kw">for </span><span class="kw-2">mut </span>doc <span class="kw">in </span>documents {
        <span class="kw">let </span><span class="kw-2">mut </span>first = <span class="bool-val">false</span>;
        doc.renumber_objects_with(max_id);

        max_id = doc.max_id + <span class="number">1</span>;

        documents_pages.extend(
            doc
                    .get_pages()
                    .into_iter()
                    .map(|(<span class="kw">_</span>, object_id)| {
                        <span class="kw">if </span>!first {
                            <span class="kw">let </span>bookmark = Bookmark::new(String::from(<span class="macro">format!</span>(<span class="string">"Page_{}"</span>, pagenum)), [<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>], <span class="number">0</span>, object_id);
                            document.add_bookmark(bookmark, <span class="prelude-val">None</span>);
                            first = <span class="bool-val">true</span>;
                            pagenum += <span class="number">1</span>;
                        }

                        (
                            object_id,
                            doc.get_object(object_id).unwrap().to_owned(),
                        )
                    })
                    .collect::&lt;BTreeMap&lt;ObjectId, Object&gt;&gt;(),
        );
        documents_objects.extend(doc.objects);
    }

    <span class="comment">// "Catalog" and "Pages" are mandatory.
    </span><span class="kw">let </span><span class="kw-2">mut </span>catalog_object: <span class="prelude-ty">Option</span>&lt;(ObjectId, Object)&gt; = <span class="prelude-val">None</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>pages_object: <span class="prelude-ty">Option</span>&lt;(ObjectId, Object)&gt; = <span class="prelude-val">None</span>;

    <span class="comment">// Process all objects except "Page" type
    </span><span class="kw">for </span>(object_id, object) <span class="kw">in </span>documents_objects.iter() {
        <span class="comment">// We have to ignore "Page" (as are processed later), "Outlines" and "Outline" objects.
        // All other objects should be collected and inserted into the main Document.
        </span><span class="kw">match </span>object.type_name().unwrap_or(<span class="string">b""</span>) {
            <span class="string">b"Catalog" </span>=&gt; {
                <span class="comment">// Collect a first "Catalog" object and use it for the future "Pages".
                </span>catalog_object = <span class="prelude-val">Some</span>((
                    <span class="kw">if let </span><span class="prelude-val">Some</span>((id, <span class="kw">_</span>)) = catalog_object {
                        id
                    } <span class="kw">else </span>{
                        <span class="kw-2">*</span>object_id
                    },
                    object.clone(),
                ));
            }
            <span class="string">b"Pages" </span>=&gt; {
                <span class="comment">// Collect and update a first "Pages" object and use it for the future "Catalog"
                // We have also to merge all dictionaries of the old and the new "Pages" object
                </span><span class="kw">if let </span><span class="prelude-val">Ok</span>(dictionary) = object.as_dict() {
                    <span class="kw">let </span><span class="kw-2">mut </span>dictionary = dictionary.clone();
                    <span class="kw">if let </span><span class="prelude-val">Some</span>((<span class="kw">_</span>, <span class="kw-2">ref </span>object)) = pages_object {
                        <span class="kw">if let </span><span class="prelude-val">Ok</span>(old_dictionary) = object.as_dict() {
                            dictionary.extend(old_dictionary);
                        }
                    }

                    pages_object = <span class="prelude-val">Some</span>((
                        <span class="kw">if let </span><span class="prelude-val">Some</span>((id, <span class="kw">_</span>)) = pages_object {
                            id
                        } <span class="kw">else </span>{
                            <span class="kw-2">*</span>object_id
                        },
                        Object::Dictionary(dictionary),
                    ));
                }
            }
            <span class="string">b"Page" </span>=&gt; {}     <span class="comment">// Ignored, processed later and separately
            </span><span class="string">b"Outlines" </span>=&gt; {} <span class="comment">// Ignored, not supported yet
            </span><span class="string">b"Outline" </span>=&gt; {}  <span class="comment">// Ignored, not supported yet
            </span><span class="kw">_ </span>=&gt; {
                document.objects.insert(<span class="kw-2">*</span>object_id, object.clone());
            }
        }
    }

    <span class="comment">// If no "Pages" object found, abort.
    </span><span class="kw">if </span>pages_object.is_none() {
        <span class="macro">println!</span>(<span class="string">"Pages root not found."</span>);

        <span class="kw">return </span><span class="prelude-val">Ok</span>(());
    }

    <span class="comment">// Iterate over all "Page" objects and collect into the parent "Pages" created before
    </span><span class="kw">for </span>(object_id, object) <span class="kw">in </span>documents_pages.iter() {
        <span class="kw">if let </span><span class="prelude-val">Ok</span>(dictionary) = object.as_dict() {
            <span class="kw">let </span><span class="kw-2">mut </span>dictionary = dictionary.clone();
            dictionary.set(<span class="string">"Parent"</span>, pages_object.as_ref().unwrap().<span class="number">0</span>);

            document
                    .objects
                    .insert(<span class="kw-2">*</span>object_id, Object::Dictionary(dictionary));
        }
    }

    <span class="comment">// If no "Catalog" found, abort.
    </span><span class="kw">if </span>catalog_object.is_none() {
        <span class="macro">println!</span>(<span class="string">"Catalog root not found."</span>);

        <span class="kw">return </span><span class="prelude-val">Ok</span>(());
    }

    <span class="kw">let </span>catalog_object = catalog_object.unwrap();
    <span class="kw">let </span>pages_object = pages_object.unwrap();

    <span class="comment">// Build a new "Pages" with updated fields
    </span><span class="kw">if let </span><span class="prelude-val">Ok</span>(dictionary) = pages_object.<span class="number">1</span>.as_dict() {
        <span class="kw">let </span><span class="kw-2">mut </span>dictionary = dictionary.clone();

        <span class="comment">// Set new pages count
        </span>dictionary.set(<span class="string">"Count"</span>, documents_pages.len() <span class="kw">as </span>u32);

        <span class="comment">// Set new "Kids" list (collected from documents pages) for "Pages"
        </span>dictionary.set(
            <span class="string">"Kids"</span>,
            documents_pages
                    .into_iter()
                    .map(|(object_id, <span class="kw">_</span>)| Object::Reference(object_id))
                    .collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(),
        );

        document
                .objects
                .insert(pages_object.<span class="number">0</span>, Object::Dictionary(dictionary));
    }

    <span class="comment">// Build a new "Catalog" with updated fields
    </span><span class="kw">if let </span><span class="prelude-val">Ok</span>(dictionary) = catalog_object.<span class="number">1</span>.as_dict() {
        <span class="kw">let </span><span class="kw-2">mut </span>dictionary = dictionary.clone();
        dictionary.set(<span class="string">"Pages"</span>, pages_object.<span class="number">0</span>);
        dictionary.remove(<span class="string">b"Outlines"</span>); <span class="comment">// Outlines not supported in merged PDFs

        </span>document
                .objects
                .insert(catalog_object.<span class="number">0</span>, Object::Dictionary(dictionary));
    }

    document.trailer.set(<span class="string">"Root"</span>, catalog_object.<span class="number">0</span>);

    <span class="comment">// Update the max internal ID as wasn't updated before due to direct objects insertion
    </span>document.max_id = document.objects.len() <span class="kw">as </span>u32;

    <span class="comment">// Reorder all new Document objects
    </span>document.renumber_objects();

    <span class="comment">// Set any Bookmarks to the First child if they are not set to a page
    </span>document.adjust_zero_pages();

    <span class="comment">// Set all bookmarks to the PDF Object tree then set the Outlines to the Bookmark content map.
    </span><span class="kw">if let </span><span class="prelude-val">Some</span>(n) = document.build_outline() {
        <span class="kw">if let </span><span class="prelude-val">Ok</span>(Object::Dictionary(dict)) = document.get_object_mut(catalog_object.<span class="number">0</span>) {
            dict.set(<span class="string">"Outlines"</span>, Object::Reference(n));
        }
    }

    document.compress();

    <span class="comment">// Save the merged PDF.
    // Store file in current working directory.
    // Note: Line is excluded when running doc tests
    </span><span class="kw">if </span><span class="bool-val">false </span>{
        document.save(<span class="string">"merged.pdf"</span>).unwrap();
    }

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<ul>
<li>Modify PDF document</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lopdf::Document;

<span class="comment">// For this example to work a parser feature needs to be enabled
</span><span class="attr">#[cfg(not(feature = <span class="string">"async"</span>))]
#[cfg(feature = <span class="string">"nom_parser"</span>)]
</span>{
    <span class="kw">let </span><span class="kw-2">mut </span>doc = Document::load(<span class="string">"assets/example.pdf"</span>).unwrap();

    doc.version = <span class="string">"1.4"</span>.to_string();
    doc.replace_text(<span class="number">1</span>, <span class="string">"Hello World!"</span>, <span class="string">"Modified text!"</span>);
    <span class="comment">// Store file in current working directory.
    // Note: Line is excluded when running tests
    </span><span class="kw">if </span><span class="bool-val">false </span>{
        doc.save(<span class="string">"modified.pdf"</span>).unwrap();
    }
}

<span class="attr">#[cfg(feature = <span class="string">"async"</span>)]
#[cfg(feature = <span class="string">"nom_parser"</span>)]
</span>{
    tokio::runtime::Builder::new_current_thread()
        .build()
        .expect(<span class="string">"Failed to create runtime"</span>)
        .block_on(<span class="kw">async move </span>{
            <span class="kw">let </span><span class="kw-2">mut </span>doc = Document::load(<span class="string">"assets/example.pdf"</span>).<span class="kw">await</span>.unwrap();
            
            doc.version = <span class="string">"1.4"</span>.to_string();
            doc.replace_text(<span class="number">1</span>, <span class="string">"Hello World!"</span>, <span class="string">"Modified text!"</span>);
            <span class="comment">// Store file in current working directory.
            // Note: Line is excluded when running tests
            </span><span class="kw">if </span><span class="bool-val">false </span>{
                doc.save(<span class="string">"modified.pdf"</span>).unwrap();
            }
    });
}</code></pre></div>
<h3 id="faq"><a class="doc-anchor" href="#faq">ยง</a>FAQ</h3>
<ul>
<li>
<p>Why does the library keep everything in memory as high-level objects until finally serializing the entire document?</p>
<p>Normally, a PDF document wonโt be very large, ranging from tens of KB to hundreds of MB. Memory size is not a bottle neck for todayโs computer.
By keeping the whole document in memory, the stream length can be pre-calculated, no need to use a reference object for the Length entry.
The resulting PDF file is smaller for distribution and faster for PDF consumers to process.</p>
<p>Producing is a one-time effort, while consuming is many more.</p>
</li>
</ul>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="mod" href="content/index.html" title="mod lopdf::content">content</a></dt><dt><a class="mod" href="encryption/index.html" title="mod lopdf::encryption">encryption</a></dt><dt><a class="mod" href="filters/index.html" title="mod lopdf::filters">filters</a></dt><dt><a class="mod" href="xobject/index.html" title="mod lopdf::xobject">xobject</a></dt><dt><a class="mod" href="xref/index.html" title="mod lopdf::xref">xref</a></dt></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="macro" href="macro.dictionary.html" title="macro lopdf::dictionary">dictionary</a></dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Bookmark.html" title="struct lopdf::Bookmark">Bookmark</a></dt><dt><a class="struct" href="struct.Destination.html" title="struct lopdf::Destination">Destination</a></dt><dt><a class="struct" href="struct.Dictionary.html" title="struct lopdf::Dictionary">Dictionary</a></dt><dd>Dictionary object.</dd><dt><a class="struct" href="struct.Document.html" title="struct lopdf::Document">Document</a></dt><dd>A PDF document.</dd><dt><a class="struct" href="struct.IncrementalDocument.html" title="struct lopdf::IncrementalDocument">Incremental<wbr>Document</a></dt><dt><a class="struct" href="struct.ObjectStream.html" title="struct lopdf::ObjectStream">Object<wbr>Stream</a></dt><dt><a class="struct" href="struct.Reader.html" title="struct lopdf::Reader">Reader</a></dt><dt><a class="struct" href="struct.Stream.html" title="struct lopdf::Stream">Stream</a></dt><dd>Stream object
Warning - all streams must be indirect objects, while
the stream dictionary may be a direct object</dd><dt><a class="struct" href="struct.Toc.html" title="struct lopdf::Toc">Toc</a></dt></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Encoding.html" title="enum lopdf::Encoding">Encoding</a></dt><dt><a class="enum" href="enum.Error.html" title="enum lopdf::Error">Error</a></dt><dt><a class="enum" href="enum.Object.html" title="enum lopdf::Object">Object</a></dt><dd>Basic PDF object types defined in an enum.</dd><dt><a class="enum" href="enum.Outline.html" title="enum lopdf::Outline">Outline</a></dt><dt><a class="enum" href="enum.StringFormat.html" title="enum lopdf::StringFormat">String<wbr>Format</a></dt><dd>String objects can be written in two formats.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="fn" href="fn.decode_text_string.html" title="fn lopdf::decode_text_string">decode_<wbr>text_<wbr>string</a></dt><dd>Decodes a text string.
Depending on the BOM at the start of the string, a different encoding is chosen.
All encodings specified in PDF2.0 are supported (PDFDocEncoding, UTF-16BE,
and UTF-8).</dd><dt><a class="fn" href="fn.encode_utf8.html" title="fn lopdf::encode_utf8">encode_<wbr>utf8</a></dt><dd>Encodes the given <code>str</code> to UTF-8. This method of encoding text strings
is first specified in PDF2.0 and reader support is still lacking
(notably, Adobe Acrobat Reader doesnโt support it at the time of writing).
Thus, using it is <strong>NOT RECOMMENDED</strong>.</dd><dt><a class="fn" href="fn.encode_utf16_be.html" title="fn lopdf::encode_utf16_be">encode_<wbr>utf16_<wbr>be</a></dt><dd>Encodes the given <code>str</code> to UTF-16BE.
The recommended way to encode text strings, as it supports all of
unicode and all major PDF readers support it.</dd><dt><a class="fn" href="fn.text_string.html" title="fn lopdf::text_string">text_<wbr>string</a></dt><dd>Creates a text string.
If the input only contains ASCII characters, the string is encoded
in PDFDocEncoding, otherwise in UTF-16BE.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="type" href="type.ObjectId.html" title="type lopdf::ObjectId">Object<wbr>Id</a></dt><dd>Object identifier consists of two parts: object number and generation number.</dd><dt><a class="type" href="type.Result.html" title="type lopdf::Result">Result</a></dt></dl></section></div></main></body></html>