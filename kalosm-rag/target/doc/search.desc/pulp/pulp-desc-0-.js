searchState.loadedDescShard("pulp", 0, "<code>pulp</code> is a safe abstraction over SIMD instructions, that …\nTypes that allow [de]interleaving.\nLow level aarch64 API.\nContains the square of the norm in both the real and …\nContains the square of the norm in both the real and …\nContains the max norm in both the real and imaginary …\nContains the max norm in both the real and imaginary …\nSplits a slice into chunks of equal size (known at compile …\nSplits a slice into chunks of equal size (known at compile …\nBitmask type for 16 elements, used for mask operations on …\nBitmask type for 32 elements, used for mask operations on …\nBitmask type for 64 elements, used for mask operations on …\nBitmask type for 8 elements, used for mask operations on …\nSafe transmute function.\nSafe transmute macro.\nSafe lossy transmute function, where the destination type …\nComputes <code>conj(a) * b + c</code>\nComputes <code>conj(a) * b + c</code>\nComputes <code>conj(a) * b</code>\nComputes <code>conj(a) * b</code>\nPlatform dependent intrinsics.\nA 512-bit SIMD vector with 16 elements of type <code>f32</code>.\nA 128-bit SIMD vector with 4 elements of type <code>f32</code>.\nA 256-bit SIMD vector with 8 elements of type <code>f32</code>.\nA 128-bit SIMD vector with 2 elements of type <code>f64</code>.\nA 256-bit SIMD vector with 4 elements of type <code>f64</code>.\nA 512-bit SIMD vector with 8 elements of type <code>f64</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nA 256-bit SIMD vector with 16 elements of type <code>i16</code>.\nA 512-bit SIMD vector with 32 elements of type <code>i16</code>.\nA 128-bit SIMD vector with 8 elements of type <code>i16</code>.\nA 512-bit SIMD vector with 16 elements of type <code>i32</code>.\nA 128-bit SIMD vector with 4 elements of type <code>i32</code>.\nA 256-bit SIMD vector with 8 elements of type <code>i32</code>.\nA 128-bit SIMD vector with 2 elements of type <code>i64</code>.\nA 256-bit SIMD vector with 4 elements of type <code>i64</code>.\nA 512-bit SIMD vector with 8 elements of type <code>i64</code>.\nA 128-bit SIMD vector with 16 elements of type <code>i8</code>.\nA 256-bit SIMD vector with 32 elements of type <code>i8</code>.\nA 512-bit SIMD vector with 64 elements of type <code>i8</code>.\nImaginary portion of the complex number\nImaginary portion of the complex number\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>false</code> if the mask bits are all zero, otherwise …\nReturns <code>false</code> if the mask bits are all zero, otherwise …\nReturns <code>false</code> if the mask bits are all zero, otherwise …\nReturns <code>false</code> if the mask bits are all zero, otherwise …\nMask type with 16 bits. Its bit pattern is either all ones …\nA 256-bit SIMD vector with 16 elements of type <code>m16</code>.\nA 128-bit SIMD vector with 8 elements of type <code>m16</code>.\nMask type with 32 bits. Its bit pattern is either all ones …\nA 512-bit SIMD vector with 16 elements of type <code>m32</code>.\nA 128-bit SIMD vector with 4 elements of type <code>m32</code>.\nA 256-bit SIMD vector with 8 elements of type <code>m32</code>.\nMask type with 64 bits. Its bit pattern is either all ones …\nA 128-bit SIMD vector with 2 elements of type <code>m64</code>.\nA 256-bit SIMD vector with 4 elements of type <code>m64</code>.\nA 512-bit SIMD vector with 8 elements of type <code>m64</code>.\nMask type with 8 bits. Its bit pattern is either all ones …\nA 128-bit SIMD vector with 16 elements of type <code>m8</code>.\nA 256-bit SIMD vector with 32 elements of type <code>m8</code>.\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nComputes <code>a * b + c</code>\nComputes <code>a * b + c</code>\nComputes <code>a * b</code>\nComputes <code>a * b</code>\nReturns a mask with all bits set one, if <code>flag</code> is true, …\nReturns a mask with all bits set one, if <code>flag</code> is true, …\nReturns a mask with all bits set one, if <code>flag</code> is true, …\nReturns a mask with all bits set one, if <code>flag</code> is true, …\nReal portion of the complex number\nReal portion of the complex number\nA 256-bit SIMD vector with 16 elements of type <code>u16</code>.\nA 512-bit SIMD vector with 32 elements of type <code>u16</code>.\nA 128-bit SIMD vector with 8 elements of type <code>u16</code>.\nA 512-bit SIMD vector with 16 elements of type <code>u32</code>.\nA 128-bit SIMD vector with 4 elements of type <code>u32</code>.\nA 256-bit SIMD vector with 8 elements of type <code>u32</code>.\nA 128-bit SIMD vector with 2 elements of type <code>u64</code>.\nA 256-bit SIMD vector with 4 elements of type <code>u64</code>.\nA 512-bit SIMD vector with 8 elements of type <code>u64</code>.\nA 128-bit SIMD vector with 16 elements of type <code>u8</code>.\nA 256-bit SIMD vector with 32 elements of type <code>u8</code>.\nA 512-bit SIMD vector with 64 elements of type <code>u8</code>.\naarch64 arch\nAdds the elements of each lane of <code>a</code> and <code>b</code>.\nAdds the elements of each lane of <code>a</code> and <code>b</code>.\nReturns the bitwise AND of <code>a</code> and <code>b</code>.\nReturns the bitwise AND of <code>a</code> and <code>b</code>.\nReturns the bitwise AND of <code>a</code> and <code>b</code>.\nReturns the bitwise AND of <code>a</code> and <code>b</code>.\nReturns the bitwise AND of <code>a</code> and <code>b</code>.\nReturns the bitwise AND of <code>a</code> and <code>b</code>.\nReturns the bitwise AND of <code>a</code> and <code>b</code>.\nReturns the bitwise AND of <code>a</code> and <code>b</code>.\nReturns the bitwise AND of <code>a</code> and <code>b</code>.\nReturns the bitwise AND of <code>a</code> and <code>b</code>.\nReturns the bitwise AND of <code>a</code> and <code>b</code>.\nReturns the bitwise AND of <code>a</code> and <code>b</code>.\nReturns the bitwise AND of <code>a</code> and <code>b</code>.\nReturns the bitwise AND of <code>a</code> and <code>b</code>.\nReturns the bitwise AND of NOT <code>a</code> and <code>b</code>.\nReturns the bitwise AND of NOT <code>a</code> and <code>b</code>.\nReturns the bitwise AND of NOT <code>a</code> and <code>b</code>.\nReturns the bitwise AND of NOT <code>a</code> and <code>b</code>.\nReturns the bitwise AND of NOT <code>a</code> and <code>b</code>.\nReturns the bitwise AND of NOT <code>a</code> and <code>b</code>.\nReturns the bitwise AND of NOT <code>a</code> and <code>b</code>.\nReturns the bitwise AND of NOT <code>a</code> and <code>b</code>.\nReturns the bitwise AND of NOT <code>a</code> and <code>b</code>.\nReturns the bitwise AND of NOT <code>a</code> and <code>b</code>.\nReturns the bitwise AND of NOT <code>a</code> and <code>b</code>.\nReturns the bitwise AND of NOT <code>a</code> and <code>b</code>.\nReturns the bitwise AND of NOT <code>a</code> and <code>b</code>.\nReturns the bitwise AND of NOT <code>a</code> and <code>b</code>.\nCompares the elements in each lane of <code>a</code> and <code>b</code> for equality.\nCompares the elements in each lane of <code>a</code> and <code>b</code> for equality.\nCompares the elements in each lane of <code>a</code> and <code>b</code> for equality.\nCompares the elements in each lane of <code>a</code> and <code>b</code> for equality.\nCompares the elements in each lane of <code>a</code> and <code>b</code> for equality.\nCompares the elements in each lane of <code>a</code> and <code>b</code> for equality.\nCompares the elements in each lane of <code>a</code> and <code>b</code> for equality.\nCompares the elements in each lane of <code>a</code> and <code>b</code> for equality.\nCompares the elements in each lane of <code>a</code> and <code>b</code> for equality.\nCompares the elements in each lane of <code>a</code> and <code>b</code> for equality.\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nCompares the elements in each lane of <code>a</code> and <code>b</code> for …\nDetects the best available instruction set.\nDivides the elements of each lane of <code>a</code> and <code>b</code>.\nDivides the elements of each lane of <code>a</code> and <code>b</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the required CPU features for this type …\nReturns <code>true</code> if the required CPU features for this type …\nChecks if the elements in each lane of <code>a</code> are NaN.\nChecks if the elements in each lane of <code>a</code> are NaN.\nChecks if the elements in each lane of <code>a</code> are not NaN.\nChecks if the elements in each lane of <code>a</code> are not NaN.\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nComputes the elementwise maximum of each lane of <code>a</code> and <code>b</code>.\nComputes the elementwise maximum of each lane of <code>a</code> and <code>b</code>.\nComputes the elementwise minimum of each lane of <code>a</code> and <code>b</code>.\nComputes the elementwise minimum of each lane of <code>a</code> and <code>b</code>.\nMultiplies the elements of each lane of <code>a</code> and <code>b</code> and adds …\nMultiplies the elements of each lane of <code>a</code> and <code>b</code> and adds …\nMultiplies the elements of each lane of <code>a</code> and <code>b</code>.\nMultiplies the elements of each lane of <code>a</code> and <code>b</code>.\nDetects the best available instruction set.\nReturns a SIMD token type without checking if the required …\nReturns a SIMD token type without checking if the required …\nReturns the bitwise NOT of <code>a</code>.\nReturns the bitwise NOT of <code>a</code>.\nReturns the bitwise NOT of <code>a</code>.\nReturns the bitwise NOT of <code>a</code>.\nReturns the bitwise NOT of <code>a</code>.\nReturns the bitwise NOT of <code>a</code>.\nReturns the bitwise NOT of <code>a</code>.\nReturns the bitwise NOT of <code>a</code>.\nReturns the bitwise NOT of <code>a</code>.\nReturns the bitwise NOT of <code>a</code>.\nReturns the bitwise NOT of <code>a</code>.\nReturns the bitwise NOT of <code>a</code>.\nReturns the bitwise OR of <code>a</code> and <code>b</code>.\nReturns the bitwise OR of <code>a</code> and <code>b</code>.\nReturns the bitwise OR of <code>a</code> and <code>b</code>.\nReturns the bitwise OR of <code>a</code> and <code>b</code>.\nReturns the bitwise OR of <code>a</code> and <code>b</code>.\nReturns the bitwise OR of <code>a</code> and <code>b</code>.\nReturns the bitwise OR of <code>a</code> and <code>b</code>.\nReturns the bitwise OR of <code>a</code> and <code>b</code>.\nReturns the bitwise OR of <code>a</code> and <code>b</code>.\nReturns the bitwise OR of <code>a</code> and <code>b</code>.\nReturns the bitwise OR of <code>a</code> and <code>b</code>.\nReturns the bitwise OR of <code>a</code> and <code>b</code>.\nReturns the bitwise OR of <code>a</code> and <code>b</code>.\nReturns the bitwise OR of <code>a</code> and <code>b</code>.\nCombines <code>if_true</code> and <code>if_false</code>, selecting elements from …\nCombines <code>if_true</code> and <code>if_false</code>, selecting elements from …\nCombines <code>if_true</code> and <code>if_false</code>, selecting elements from …\nCombines <code>if_true</code> and <code>if_false</code>, selecting elements from …\nCombines <code>if_true</code> and <code>if_false</code>, selecting elements from …\nCombines <code>if_true</code> and <code>if_false</code>, selecting elements from …\nCombines <code>if_true</code> and <code>if_false</code>, selecting elements from …\nCombines <code>if_true</code> and <code>if_false</code>, selecting elements from …\nCombines <code>if_true</code> and <code>if_false</code>, selecting elements from …\nCombines <code>if_true</code> and <code>if_false</code>, selecting elements from …\nShift the bits of each lane of <code>a</code> to the left by <code>AMOUNT</code>, …\nShift the bits of each lane of <code>a</code> to the left by <code>AMOUNT</code>, …\nShift the bits of each lane of <code>a</code> to the left by <code>AMOUNT</code>, …\nShift the bits of each lane of <code>a</code> to the left by <code>AMOUNT</code>, …\nShift the bits of each lane of <code>a</code> to the left by <code>AMOUNT</code>, …\nShift the bits of each lane of <code>a</code> to the left by <code>AMOUNT</code>, …\nShift the bits of each lane of <code>a</code> to the left by <code>AMOUNT</code>, …\nShift the bits of each lane of <code>a</code> to the left by <code>AMOUNT</code>, …\nShift the bits of each lane of <code>a</code> to the left by the …\nShift the bits of each lane of <code>a</code> to the left by the …\nShift the bits of each lane of <code>a</code> to the left by the …\nShift the bits of each lane of <code>a</code> to the left by the …\nShift the bits of each lane of <code>a</code> to the left by the …\nShift the bits of each lane of <code>a</code> to the left by the …\nShift the bits of each lane of <code>a</code> to the left by the …\nShift the bits of each lane of <code>a</code> to the left by the …\nShift the bits of each lane of <code>a</code> to the left by <code>AMOUNT</code>, …\nShift the bits of each lane of <code>a</code> to the left by <code>AMOUNT</code>, …\nShift the bits of each lane of <code>a</code> to the left by <code>AMOUNT</code>, …\nShift the bits of each lane of <code>a</code> to the left by <code>AMOUNT</code>, …\nShift the bits of each lane of <code>a</code> to the left by <code>AMOUNT</code>, …\nShift the bits of each lane of <code>a</code> to the left by <code>AMOUNT</code>, …\nShift the bits of each lane of <code>a</code> to the left by <code>AMOUNT</code>, …\nShift the bits of each lane of <code>a</code> to the left by <code>AMOUNT</code>, …\nReturns a SIMD vector with all lanes set to the given …\nReturns a SIMD vector with all lanes set to the given …\nReturns a SIMD vector with all lanes set to the given …\nReturns a SIMD vector with all lanes set to the given …\nReturns a SIMD vector with all lanes set to the given …\nReturns a SIMD vector with all lanes set to the given …\nReturns a SIMD vector with all lanes set to the given …\nReturns a SIMD vector with all lanes set to the given …\nReturns a SIMD vector with all lanes set to the given …\nReturns a SIMD vector with all lanes set to the given …\nReturns a SIMD vector with all lanes set to the given …\nReturns a SIMD vector with all lanes set to the given …\nReturns a SIMD vector with all lanes set to the given …\nReturns a SIMD vector with all lanes set to the given …\nSubtracts the elements of each lane of <code>a</code> and <code>b</code>.\nSubtracts the elements of each lane of <code>a</code> and <code>b</code>.\nTakes a proof of the existence of this SIMD token (<code>self</code>), …\nTakes a proof of the existence of this SIMD token (<code>self</code>), …\nReturns a SIMD token type if the required CPU features for …\nReturns a SIMD token type if the required CPU features for …\nVectorizes the given function as if the CPU features for …\nVectorizes the given function as if the CPU features for …\nAdds the elements of each lane of <code>a</code> and <code>b</code>, with wrapping …\nAdds the elements of each lane of <code>a</code> and <code>b</code>, with wrapping …\nAdds the elements of each lane of <code>a</code> and <code>b</code>, with wrapping …\nAdds the elements of each lane of <code>a</code> and <code>b</code>, with wrapping …\nAdds the elements of each lane of <code>a</code> and <code>b</code>, with wrapping …\nAdds the elements of each lane of <code>a</code> and <code>b</code>, with wrapping …\nAdds the elements of each lane of <code>a</code> and <code>b</code>, with wrapping …\nAdds the elements of each lane of <code>a</code> and <code>b</code>, with wrapping …\nSubtracts the elements of each lane of <code>a</code> and <code>b</code>, with …\nSubtracts the elements of each lane of <code>a</code> and <code>b</code>, with …\nSubtracts the elements of each lane of <code>a</code> and <code>b</code>, with …\nSubtracts the elements of each lane of <code>a</code> and <code>b</code>, with …\nSubtracts the elements of each lane of <code>a</code> and <code>b</code>, with …\nSubtracts the elements of each lane of <code>a</code> and <code>b</code>, with …\nSubtracts the elements of each lane of <code>a</code> and <code>b</code>, with …\nSubtracts the elements of each lane of <code>a</code> and <code>b</code>, with …\nReturns the bitwise XOR of <code>a</code> and <code>b</code>.\nReturns the bitwise XOR of <code>a</code> and <code>b</code>.\nReturns the bitwise XOR of <code>a</code> and <code>b</code>.\nReturns the bitwise XOR of <code>a</code> and <code>b</code>.\nReturns the bitwise XOR of <code>a</code> and <code>b</code>.\nReturns the bitwise XOR of <code>a</code> and <code>b</code>.\nReturns the bitwise XOR of <code>a</code> and <code>b</code>.\nReturns the bitwise XOR of <code>a</code> and <code>b</code>.\nReturns the bitwise XOR of <code>a</code> and <code>b</code>.\nReturns the bitwise XOR of <code>a</code> and <code>b</code>.\nReturns the bitwise XOR of <code>a</code> and <code>b</code>.\nReturns the bitwise XOR of <code>a</code> and <code>b</code>.\nReturns the bitwise XOR of <code>a</code> and <code>b</code>.\nReturns the bitwise XOR of <code>a</code> and <code>b</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")