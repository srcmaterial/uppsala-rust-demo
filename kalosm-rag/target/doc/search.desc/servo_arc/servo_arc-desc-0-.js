searchState.loadedDescShard("servo_arc", 0, "Fork of Arc for Servo. This has the following advantages …\nAn atomically reference counted shared pointer\nA “borrowed <code>Arc</code>”. This is a pointer to a T that is …\nA tagged union that can represent <code>Arc&lt;A&gt;</code> or <code>Arc&lt;B&gt;</code> while …\nThis represents a borrow of an <code>ArcUnion</code>.\nStructure to allow Arc-managing some fixed-sized data and …\nHeader data with an inline length. Consumers that use …\nA “thin” <code>Arc</code> containing dynamically sized data\nAn <code>Arc</code> that is known to be uniquely owned\nReturns a borrow of the first type if applicable, …\nReturns a borrow of the second type if applicable, …\nConvert to an initialized Arc.\nReturns an enum representing a borrow of either A or B.\nProduce a pointer to the data that can be converted back …\nClone this as an <code>Arc&lt;T&gt;</code>. This bumps the refcount.\nReturns a mutable reference to the slice.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates an <code>ArcUnion</code> from an instance of the first type.\nCreates an Arc for a HeaderSlice using the given header …\nCreates a <code>ThinArc</code> for a HeaderSlice using the given header …\nCreates an Arc for a HeaderSlice using the given header …\nReconstruct the Arc from a raw pointer obtained from …\nLike from_raw, but returns an addrefed arc instead.\nFor constructing from a reference known to be Arc-backed, …\nCreates an <code>ArcUnion</code> from an instance of the second type.\nConverts a <code>ThinArc</code> into an <code>Arc</code>. This consumes the <code>ThinArc</code>, …\nSimilar to deref, but uses the lifetime |a| rather than …\nProvides mutable access to the contents <em>if</em> the <code>Arc</code> is …\nThe fixed-sized data.\nThe fixed-sized data.\nReturns a mutable reference to the header.\nReturns the address on the heap of the Arc itself – not …\nIf this is a static ThinArc, this returns null.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the Arc to a raw pointer, suitable for use across …\nConverts an <code>Arc</code> into a <code>ThinArc</code>. This consumes the <code>Arc</code>, so …\nReturns true if this <code>ArcUnion</code> contains the first type.\nReturns true if this <code>ArcUnion</code> contains the second type.\nWhether or not the <code>Arc</code> is a static reference.\nWhether or not the <code>Arc</code> is uniquely owned (is the refcount …\nMakes a mutable reference to the <code>Arc</code>, cloning if necessary\nMarks this <code>Arc</code> as intentionally leaked for the purposes of …\nConstruct an <code>Arc&lt;T&gt;</code>\nConstruct a new UniqueArc\nCreates a new HeaderWithLength.\nConstruct an intentionally-leaked arc.\nCreate a new static Arc (one that won’t reference count …\nConstruct an uninitialized arc\nReturns the address on the heap of the ThinArc itself – …\nTest pointer equality between the two Arcs, i.e. they must …\nReturns true if the two values are pointer-equal.\nCompare two <code>ArcBorrow</code>s via pointer equality. Will only …\nConvert to a shareable Arc once we’re done mutating it\nThe dynamically-sized data.\nCreate a static <code>ThinArc</code> for a HeaderSlice using the given …\nTemporarily converts |self| into a bonafide Arc and …\nTemporarily converts |self| into a bonafide Arc and …")