searchState.loadedDescShard("selectors", 0, "A cache to speed up matching of nth-index-like selectors.\nOpaque representation of an Element, for identity …\nSets selector flags on the elemnt itself or the parent, …\nReturns the assigned  element this element is assigned to.\nReturns the assigned  element this element is assigned to.\nCounting and non-counting Bloom filters tuned for use as …\nThe host of the containing shadow root, if any.\nSkips non-element nodes\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the appropriate cache for the given parameters.\nEmpty string for no namespace\nReturns whether this element should ignore matching nth …\nReturns whether this element should ignore matching nth …\nReturns the mapping from the <code>exportparts</code> attribute in the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether this element matches <code>:empty</code>.\nReturns whether the element is an HTML  element.\nWhether this element is a <code>link</code>.\nWhether we’re matching on a pseudo-element.\nReturns whether this element matches <code>:root</code>, i.e. whether …\nWhether this element and the <code>other</code> element have the same …\nCreates a new OpaqueElement from an arbitrarily-typed …\nSkips non-element nodes\nConverts self into an opaque representation.\nWhether the parent node of this element is a shadow root.\nSkips non-element nodes\nThe parent of a given pseudo-element, after matching a …\nThe parent of a given pseudo-element, after matching a …\nSmall helpers to abstract over different containers.\nVisitor traits for selectors.\n‘i’ was specified.\nNo flags were specified and HTML says this is a …\nNo flags were specified and HTML says this is a …\n‘s’ was specified.\nThe definition of whitespace per CSS Selectors Level 3 § …\nEmpty string for no namespace\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA counting Bloom filter with 8-bit counters.\nStorage class for a CountingBloomFilter that has 1-bit …\nStorage class for a CountingBloomFilter that has 8-bit …\nA counting Bloom filter with parameterized storage to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInserts an item with a particular hash into the bloom …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck whether the filter might contain an item with the …\nCreates a new bloom filter.\nRemoves an item with a particular hash from the bloom …\nAll links are matched as if they are unvisted.\nAll links are matched as if they are visited and unvisited …\nRelative selector was considered for a match, but the …\nSame as above, but the relative selector was part of the …\nIgnores any stateless pseudo-element selectors in the …\nWhether we need to ignore nth child selectors for this …\nLimited quirks mode.\nData associated with the matching process for a element.  …\nWhat kind of selector matching mode we should use.\nWhether we need to set selector invalidation flags on …\nNo quirks mode.\nWas not considered for any relative selector.\nDon’t ignore any pseudo-element selectors.\nQuirks mode.\nWhich quirks mode is this document in.\nWhether or not this matching considered relative selector.\nA element’s “relevant link” is the element being …\nThe mode to use when matching unvisited and visited links.\nInput with the bloom filter used to fast-reject selectors.\nThe case-sensitivity for class and ID selectors\nThe current shadow host we’re collecting :host rules for.\nExtra implementation-dependent matching data.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhether we need to ignore nth child selectors (only …\nWhether we’re matching inside a :not(..) selector.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether we’re matching a nested selector.\nThe matching-mode for this selector-matching operation.\nWhether we need to set selector flags.\nRuns F with a deeper nesting level.\nRuns F with a deeper nesting level, and marking ourselves …\nRuns F with a deeper nesting level, with the given element …\nConstructs a new <code>MatchingContext</code>.\nConstructs a new <code>MatchingContext</code> for use in visited …\nA cache to speed up nth-index-like selectors.\nAn optional hook function for checking whether a …\nThe quirks mode of the document.\nReturns the current anchor element to evaluate the …\nThe element which is going to match :scope pseudo-class. …\nReturns the current shadow host whose shadow root we’re …\nRuns F with a given shadow host which is the root of the …\nRuns F with a different VisitedHandlingMode.\nWhether a compound selector matched, and whether it was …\nSet of flags that are set on either the element or its …\nThe selector was fully matched.\nWhen a child is added or removed from the parent, the …\nThe element has an empty selector, so when a child is …\nWhen a child is added or removed from the parent, all the …\nWhen a child is added or removed from the parent, any later\nWhen a DOM mutation occurs on a child that might be …\nThe compound selector matched, and the next combinator …\nThe selector didn’t match.\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the subset of flags that apply to the parent.\nReturns the subset of flags that apply to the element.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nMatches a complex selector.\nMatches a compound selector belonging to <code>selector</code>, …\nMatches a selector, fast-rejecting against a bloom filter.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nAncestor hashes for the bloom filter. We precompute these …\nA CSS simple selector or combinator. We store both in the …\nExpect selectors to start with a combinator, assuming …\nAllow selectors to start with a combinator, prepending a …\nThe <code>:has</code> pseudo-class.\nThe <code>:host</code> pseudo-class:\nThe <code>SelectorImpl</code> this pseudo-element is used for.\nThe <code>SelectorImpl</code> this pseudo-element is used for.\nWithin this element’s direct children.\nThis element’s next sibling.\nWithin this element’s next sibling’s subtree.\nWithin this element’s subsequent siblings.\nAcross this element’s subsequent siblings and their …\nWithin this element’s subtree.\nThe <code>:is</code> pseudo-class.\nPseudo-classes\nTreat as parse error if any selector begins with a …\nA trait that represents a pseudo-class.\nnon tree-structural pseudo-classes (see: …\nThe properties that comprise an :nth- pseudoclass as of …\nThe properties that comprise an :nth- pseudoclass as of …\nAn enum for the different types of :nth- pseudoclasses\nFlag indicating if we’re parsing relative selectors.\nAnother combinator used for <code>::part()</code>, which represents the …\nThe <code>::part</code> pseudo-element. …\nA trait that represents a pseudo-element.\nA dummy combinator we use to the left of pseudo-elements.\nAn implementation-dependent pseudo-element selector.\npseudo-elements\nStorage for a relative selector.\nUsed only for relative selectors, which starts with a …\nFlag indicating where a given relative selector’s match …\nA Selector stores a sequence of simple selectors and …\nThis trait allows to define the parser implementation in …\nAnother combinator used for ::slotted(), which represent …\nThe ::slotted() pseudo-element:\nThe <code>:where</code> pseudo-class.\nWhether the pseudo-element supports a given state selector …\nWhether to allow forgiving selector-list parsing.\nReturns a selector list with a single <code>&amp;</code>\nReturns the value as a combinator if applicable, None …\nReturns the combinator at index <code>index</code> (zero-indexed from …\nReturns the combinator at index <code>index</code> (zero-indexed from …\nReturns selector data for :first-{child,of-type}\nReturns the fourth hash, reassembled from parts.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether this pseudo-class is :active or :hover.\nReturns true if this combinator is a child or descendant …\nReturns true if this is a combinator.\nWhether this selector is a featureless :host selector, …\nReturns true if this is a :host() selector.\nWhether the given function name is an alias for the <code>:is()</code> …\nReturns true if this combinator is a pseudo-element …\nReturns true if this combinator is a next- or …\nWhether this selector (pseudo-element part excluded) …\nWhether this pseudo-class belongs to:\nReturns an iterator over this selector in matching order …\nReturns an iterator over this selector in matching order …\nReturns an iterator over the entire sequence of simple …\nReturns an iterator over the sequence of simple selectors …\nSame as <code>iter()</code>, but skips <code>RelativeSelectorAnchor</code> and its …\nDetails of this error\nReturns selector data for :last-{child,of-type}\nReturns count of simple selectors and combinators in the …\nLocation where this error occurred\nSee Arc::mark_as_intentionally_leaked\nMatch space constraining hint.\nWhether this component is valid after a pseudo-element. …\nReturns selector data for …\nPrepares this iterator to point to the next sequence to …\nReturns the An+B part of the selector\nReturns selector data for :only-{child,of-type}\nParse a comma-separated list of Selectors. …\nParse a selector, without any pseudo-element.\nWhether to parse the :has pseudo-class.\nWhether to parse the <code>:host</code> pseudo-class.\nWhether to parse the <code>:where</code> pseudo-class.\nThis function can return an “Err” pseudo-element in …\nWhether to parse the selector list of nth-child() or …\nWhether to parse the ‘&amp;’ delimiter as a parent …\nWhether to parse the <code>::part()</code> pseudo-element.\nWhether to parse the <code>::slotted()</code> pseudo-element.\nReplaces the parent selector in all the items of the …\nThe selector. Guaranteed to contain <code>RelativeSelectorAnchor</code> …\nReturns remaining count of the simple selectors and …\nReturns the selector list part of the selector\nWhether attribute hashes should be collected for filtering …\nReturns the address on the heap of the ThinArc for memory …\nWhether this pseudo-element is valid after a ::slotted(..) …\nTraverse selector components inside <code>self</code>.\nA trait to abstract over a <code>push</code> method that may be …\nPush a value into self.\nThe visitor is inside :is(..)\nThe selector implementation this visitor wants to visit.\nThe visitor is inside :not(..)\nThe visitor is inside :nth-child(.. of ) or …\nThe kinds of components the visitor is visiting the …\nA trait to visit selector properties.\nThe visitor is inside :where(..)\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nConstruct a SelectorListKind for the corresponding …\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nWhether the visitor is inside :is(..)\nWhether the visitor is inside :not(..)\nWhether the visitor is inside :nth-child(.. of ) or …\nWhether the visitor is inside :where(..)\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nVisit an attribute selector that may match (there are …\nVisits a complex selector.\nVisit a nested selector list. The caller is responsible to …\nVisit a simple selector.")