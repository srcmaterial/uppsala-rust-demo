<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Store by cursor."><title>mdb_cursor_put in lmdb_master_sys - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="lmdb_master_sys" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0 (17067e9ac 2025-05-09)" data-channel="1.87.0" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../static.files/storage-82c7156e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../lmdb_master_sys/index.html">lmdb_<wbr>master_<wbr>sys</a><span class="version">0.2.5</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">mdb_<wbr>cursor_<wbr>put</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#arguments" title="Arguments">Arguments</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate lmdb_<wbr>master_<wbr>sys</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">lmdb_master_sys</a></div><h1>Function <span class="fn">mdb_cursor_put</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/lmdb_master_sys/bindings.rs.html#440-445">Source</a> </span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn mdb_cursor_put(
    cursor: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.pointer.html">*mut </a><a class="struct" href="struct.MDB_cursor.html" title="struct lmdb_master_sys::MDB_cursor">MDB_cursor</a>,
    key: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.pointer.html">*mut </a><a class="struct" href="struct.MDB_val.html" title="struct lmdb_master_sys::MDB_val">MDB_val</a>,
    data: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.pointer.html">*mut </a><a class="struct" href="struct.MDB_val.html" title="struct lmdb_master_sys::MDB_val">MDB_val</a>,
    flags: <a class="type" href="../libc/primitives/type.c_uint.html" title="type libc::primitives::c_uint">c_uint</a>,
) -&gt; <a class="type" href="../libc/primitives/type.c_int.html" title="type libc::primitives::c_int">c_int</a></code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Store by cursor.</p>
<p>This function stores key/data pairs into the database.
The cursor is positioned at the new item, or on failure usually near it.</p>
<blockquote>
<p><strong>Note:</strong> Earlier documentation incorrectly said errors would leave the
state of the cursor unchanged.</p>
</blockquote>
<h2 id="arguments"><a class="doc-anchor" href="#arguments">ยง</a>Arguments</h2>
<ul>
<li><code>cursor</code> (direction in) - A cursor handle returned by #mdb_cursor_open()</li>
<li><code>key</code> (direction in) - The key operated on.</li>
<li><code>data</code> (direction in) - The data operated on.</li>
<li><code>flags</code> (direction in) - Options for this operation. This parameter
must be set to 0 or one of the values described here.</li>
</ul>
 <ul>
	<li>#MDB_CURRENT - replace the item at the current cursor position.
		The **key** parameter must still be provided, and must match it.
		If using sorted duplicates (#MDB_DUPSORT) the data item must still
		sort into the same place. This is intended to be used when the
		new data is the same size as the old. Otherwise it will simply
		perform a delete of the old record followed by an insert.
	<li>#MDB_NODUPDATA - enter the new key/data pair only if it does not
		already appear in the database. This flag may only be specified
		if the database was opened with #MDB_DUPSORT. The function will
		return #MDB_KEYEXIST if the key/data pair already appears in the
		database.
	<li>#MDB_NOOVERWRITE - enter the new key/data pair only if the key
		does not already appear in the database. The function will return
		#MDB_KEYEXIST if the key already appears in the database, even if
		the database supports duplicates (#MDB_DUPSORT).
	<li>#MDB_RESERVE - reserve space for data of the given size, but
		don't copy the given data. Instead, return a pointer to the
		reserved space, which the caller can fill in later - before
		the next update operation or the transaction ends. This saves
		an extra memcpy if the data is being generated later. This flag
		must not be specified if the database was opened with #MDB_DUPSORT.
	<li>#MDB_APPEND - append the given key/data pair to the end of the
		database. No key comparisons are performed. This option allows
		fast bulk loading when keys are already known to be in the
		correct order. Loading unsorted keys with this flag will cause
		a #MDB_KEYEXIST error.
	<li>#MDB_APPENDDUP - as above, but for sorted dup data.
	<li>#MDB_MULTIPLE - store multiple contiguous data elements in a
		single request. This flag may only be specified if the database
		was opened with #MDB_DUPFIXED. The **data** argument must be an
		array of two MDB_vals. The mv_size of the first MDB_val must be
		the size of a single data element. The mv_data of the first MDB_val
		must point to the beginning of the array of contiguous data elements.
		The mv_size of the second MDB_val must be the count of the number
		of data elements to store. On return this field will be set to
		the count of the number of elements actually written. The mv_data
		of the second MDB_val is unused.
 </ul>
 # Returns
<p>A non-zero error value on failure and 0 on success. Some possible
errors are:</p>
 <ul>
	<li>#MDB_MAP_FULL - the database is full, see #mdb_env_set_mapsize().
	<li>#MDB_TXN_FULL - the transaction has too many dirty pages.
	<li>EACCES - an attempt was made to write in a read-only transaction.
	<li>EINVAL - an invalid parameter was specified.
 </ul></div></details></section></div></main></body></html>