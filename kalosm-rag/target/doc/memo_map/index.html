<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A concurrent insert only hash map."><title>memo_map - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="memo_map" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0 (17067e9ac 2025-05-09)" data-channel="1.87.0" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../static.files/storage-82c7156e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../memo_map/index.html">memo_<wbr>map</a><span class="version">0.3.3</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#notes-on-iteration" title="Notes on Iteration">Notes on Iteration</a></li><li><a href="#notes-on-removal" title="Notes on Removal">Notes on Removal</a></li></ul><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>memo_map</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/memo_map/lib.rs.html#1-558">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A concurrent insert only hash map.</p>
<p>This crate implements a “memo map” which is in many ways similar to a
<a href="https://doc.rust-lang.org/1.87.0/std/collections/hash/map/struct.HashMap.html" title="struct std::collections::hash::map::HashMap"><code>HashMap</code></a> with some crucial differences:</p>
<ul>
<li>Unlike a regular hash map, a memo map is thread safe and synchronized.</li>
<li>Adding or retrieving keys works through a shared reference, removing only
through a mutable reference.</li>
<li>Retrieving a value from a memo map returns a plain old reference.</li>
</ul>
<p>Together these purposes allow one to use this type of structure to
implement something similar to lazy loading in places where the API
has been constrained to references before.</p>
<p>The values in the map are individually boxed up so that resizing of the
map retains the previously issued references.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>memo_map::MemoMap;

<span class="kw">let </span>memo = MemoMap::new();
<span class="kw">let </span>one = memo.get_or_insert(<span class="kw-2">&amp;</span><span class="number">1</span>, || <span class="string">"one"</span>.to_string());
<span class="kw">let </span>one2 = memo.get_or_insert(<span class="kw-2">&amp;</span><span class="number">1</span>, || <span class="string">"not one"</span>.to_string());
<span class="macro">assert_eq!</span>(one, <span class="string">"one"</span>);
<span class="macro">assert_eq!</span>(one2, <span class="string">"one"</span>);</code></pre></div>
<h2 id="notes-on-iteration"><a class="doc-anchor" href="#notes-on-iteration">§</a>Notes on Iteration</h2>
<p>Because the memo map internally uses a mutex it needs to be held during
iteration.  This is potentially dangerous as it means you can easily
deadlock yourself when trying to use the memo map while iterating.  The
iteration functionality thus has to be used with great care.</p>
<h2 id="notes-on-removal"><a class="doc-anchor" href="#notes-on-removal">§</a>Notes on Removal</h2>
<p>Items can be removed from a memo map but this operation requires a mutable
reference to the memo map.  This is so that it can ensure that there are no
borrows outstanding that would be invalidated through the removal of the item.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Iter.html" title="struct memo_map::Iter">Iter</a></dt><dd>An iterator over the items of a <a href="struct.MemoMap.html" title="struct memo_map::MemoMap"><code>MemoMap</code></a>.</dd><dt><a class="struct" href="struct.IterMut.html" title="struct memo_map::IterMut">IterMut</a></dt><dd>A mutable iterator over a <a href="struct.MemoMap.html" title="struct memo_map::MemoMap"><code>MemoMap</code></a>.</dd><dt><a class="struct" href="struct.Keys.html" title="struct memo_map::Keys">Keys</a></dt><dd>An iterator over the keys of a <a href="struct.MemoMap.html" title="struct memo_map::MemoMap"><code>MemoMap</code></a>.</dd><dt><a class="struct" href="struct.MemoMap.html" title="struct memo_map::MemoMap">MemoMap</a></dt><dd>An insert only, thread safe hash map to memoize values.</dd><dt><a class="struct" href="struct.ValuesMut.html" title="struct memo_map::ValuesMut">Values<wbr>Mut</a></dt><dd>A mutable iterator over a <a href="struct.MemoMap.html" title="struct memo_map::MemoMap"><code>MemoMap</code></a>.</dd></dl></section></div></main></body></html>