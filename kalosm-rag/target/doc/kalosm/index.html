<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Kalosm is a simple interface for pre-trained models in rust. It makes it easy to interact with pre-trained, language, audio, and image models."><title>kalosm - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="kalosm" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0 (17067e9ac 2025-05-09)" data-channel="1.87.0" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../static.files/storage-82c7156e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../kalosm/index.html">kalosm</a><span class="version">0.4.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#quickstart" title="Quickstart!">Quickstart!</a></li><li><a href="#what-can-you-do-with-kalosm" title="What can you do with Kalosm?">What can you do with Kalosm?</a></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>kalosm</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/kalosm/lib.rs.html#1-67">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><div align="center">
  <h1>Kalosm</h1>
</div>
<div align="center">
  <!-- Crates version -->
  <a href="https://crates.io/crates/kalosm">
    <img src="https://img.shields.io/crates/v/kalosm.svg?style=flat-square"
    alt="Crates.io version" />
  </a>
  <!-- Downloads -->
  <a href="https://crates.io/crates/kalosm">
    <img src="https://img.shields.io/crates/d/kalosm.svg?style=flat-square"
      alt="Download" />
  </a>
  <!-- docs -->
  <a href="https://docs.rs/kalosm">
    <img src="https://img.shields.io/badge/docs-latest-blue.svg?style=flat-square"
      alt="docs.rs docs" />
  </a>
</div>
<p>Kalosm is a simple interface for pre-trained models in rust. It makes it easy to interact with pre-trained, language, audio, and image models.</p>
<p>There are three different packages in Kalosm:</p>
<ul>
<li><code>kalosm::language</code> - A simple interface for text generation and embedding models and surrounding tools. It includes support for search databases, and text collection from websites, RSS feeds, and search engines.</li>
<li><code>kalosm::audio</code> - A simple interface for audio transcription and surrounding tools. It includes support for microphone input, transcription with the <code>whisper</code> model, and voice activity detection.</li>
<li><code>kalosm::vision</code> - A simple interface for image generation and segmentation models and surrounding tools. It includes support for the <code>wuerstchen</code> and <code>segment-anything</code> models and integration with the <a href="https://docs.rs/image/latest/image/">image</a> crate.</li>
</ul>
<p>A complete guide for Kalosm is available on the <a href="https://floneum.com/kalosm/">Kalosm website</a>, and examples are available in the <a href="https://github.com/floneum/floneum/tree/main/interfaces/kalosm/examples">examples folder</a>.</p>
<h3 id="quickstart"><a class="doc-anchor" href="#quickstart">§</a>Quickstart!</h3>
<ol>
<li>Install <a href="https://rustup.rs/">rust</a></li>
<li>Create a new project:</li>
</ol>
<div class="example-wrap"><pre class="language-sh"><code>cargo new next-gen-ai
cd ./next-gen-ai</code></pre></div>
<ol start="3">
<li>Add Kalosm as a dependency</li>
</ol>
<div class="example-wrap"><pre class="language-sh"><code>cargo add kalosm --git https://github.com/floneum/floneum --features full
cargo add tokio --features full</code></pre></div>
<ol start="4">
<li>Add this code to your <code>main.rs</code> file</li>
</ol>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io::Write;

<span class="kw">use </span>kalosm::{<span class="kw-2">*</span>, language::<span class="kw-2">*</span>};

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>llm = Llama::new().<span class="kw">await</span>.unwrap();
    <span class="kw">let </span>prompt = <span class="string">"The following is a 300 word essay about Paris:"</span>;
    <span class="macro">print!</span>(<span class="string">"{}"</span>, prompt);

    <span class="kw">let </span><span class="kw-2">mut </span>stream = llm(prompt);

    stream.to_std_out().<span class="kw">await</span>.unwrap();
}</code></pre></div>
<ol start="5">
<li>Run your application with:</li>
</ol>
<div class="example-wrap"><pre class="language-sh"><code>cargo run --release</code></pre></div><h3 id="what-can-you-do-with-kalosm"><a class="doc-anchor" href="#what-can-you-do-with-kalosm">§</a>What can you do with Kalosm?</h3>
<p>You can think of Kalosm as the plumbing between different pre-trained models and each other or the surrounding world. Kalosm makes it easy to build applications that use pre-trained models to generate text, audio, and images. Here are some examples of what you can build with Kalosm:</p>
<details>
<summary>Local text generation</summary>
<p>The simplest way to get started with Kalosm language is to pull in one of the local large language models and use it to generate text. Kalosm supports a streaming API that allows you to generate text in real time without blocking your main thread:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>kalosm::language::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>std::error::Error&gt;&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>llm = Llama::phi_3().<span class="kw">await</span>.unwrap();
    <span class="kw">let </span>prompt = <span class="string">"The following is a 300 word essay about why the capital of France is Paris:"</span>;
    <span class="macro">print!</span>(<span class="string">"{}"</span>, prompt);

    <span class="kw">let </span><span class="kw-2">mut </span>stream = llm(prompt);

    stream.to_std_out().<span class="kw">await</span>.unwrap();

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</details>
<details>
<summary>Structured generation</summary>
<p>Natural language generation is interesting, but the more interesting aspect of text is as a universal data format. You can encode any kind of data into text with a format like json. Kalosm lets you use LLMs with structured generation to create arbitrary types from natural language inputs:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>kalosm::language::<span class="kw-2">*</span>;
<span class="kw">use </span>std::sync::Arc;

<span class="comment">// First, derive an efficient parser for your structured data
</span><span class="attr">#[derive(Parse, Clone, Debug)]
</span><span class="kw">enum </span>Class {
    Thing,
    Person,
    Animal,
}

<span class="attr">#[derive(Parse, Clone, Debug)]
</span><span class="kw">struct </span>Response {
    classification: Class,
}

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
    <span class="comment">// Then set up a task with a prompt and constraints
    </span><span class="kw">let </span>llm = Llama::new_chat().<span class="kw">await</span>.unwrap();
    <span class="kw">let </span>task = llm.task(<span class="string">"You classify the user's message as about a person, animal or thing in a JSON format"</span>)
        .with_constraints(Arc::new(Response::new_parser()));

    <span class="comment">// Finally, run the task
    </span><span class="kw">let </span>response = task(<span class="string">"The Kalosm library lets you create structured data from natural language inputs"</span>).<span class="kw">await</span>.unwrap();
    <span class="macro">println!</span>(<span class="string">"{:?}"</span>, response);
}</code></pre></div>
</details>
<details>
<summary>Cloud models</summary>
<p>Kalosm also supports cloud models like GPT4 with the same streaming API:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// You must set the environment variable OPENAI_API_KEY (https://platform.openai.com/account/api-keys) to run this example.
</span><span class="kw">use </span>kalosm::language::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>std::error::Error&gt;&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>llm = OpenAICompatibleChatModel::builder()
        .with_gpt_4o_mini()
        .build();

    <span class="kw">let </span><span class="kw-2">mut </span>chat = llm.chat();

    chat(<span class="string">"What is the capital of France?"</span>).to_std_out().<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</details>
<details>
<summary>Gather context from RSS, websites, local files, search results, and more</summary>
<p>Kalosm makes it easy to collect text data from a variety of sources. For example, you can use Kalosm to collect text from a local folder of documents, an RSS stream, a website, or a search engine:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>kalosm::language::<span class="kw-2">*</span>;
<span class="kw">use </span>std::convert::TryFrom;
<span class="kw">use </span>std::path::PathBuf;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>std::error::Error&gt;&gt; {
    <span class="comment">// Read an RSS stream
    </span><span class="kw">let </span>nyt = RssFeed::new(Url::parse(<span class="string">"https://rss.nytimes.com/services/xml/rss/nyt/US.xml"</span>).unwrap());
    <span class="comment">// Read a local folder of documents
    </span><span class="kw">let </span><span class="kw-2">mut </span>documents = DocumentFolder::try_from(PathBuf::from(<span class="string">"./documents"</span>)).unwrap();
    <span class="comment">// Read a website (either from the raw HTML or inside of a headless browser)
    </span><span class="kw">let </span>page = Page::new(Url::parse(<span class="string">"https://www.nytimes.com/live/2023/09/21/world/zelensky-russia-ukraine-news"</span>).unwrap(), BrowserMode::Static).unwrap();
    <span class="kw">let </span>document = page.article().<span class="kw">await</span>.unwrap();
    <span class="macro">println!</span>(<span class="string">"Title: {}"</span>, document.title());
    <span class="macro">println!</span>(<span class="string">"Body: {}"</span>, document.body());
    <span class="comment">// Read pages from a search engine (You must have the SERPER_API_KEY environment variable set to run this example)
    </span><span class="kw">let </span>query = <span class="string">"What is the capital of France?"</span>;
    <span class="kw">let </span>api_key = std::env::var(<span class="string">"SERPER_API_KEY"</span>).unwrap();
    <span class="kw">let </span>search_query = SearchQuery::new(query, <span class="kw-2">&amp;</span>api_key, <span class="number">5</span>);
    <span class="kw">let </span>documents = search_query.into_documents().<span class="kw">await</span>.unwrap();
    <span class="kw">let </span><span class="kw-2">mut </span>text = String::new();
    <span class="kw">for </span>document <span class="kw">in </span>documents {
        <span class="kw">for </span>word <span class="kw">in </span>document.body().split(<span class="string">' '</span>).take(<span class="number">300</span>) {
            text.push_str(word);
            text.push(<span class="string">' '</span>);
        }
        text.push(<span class="string">'\n'</span>);
    }
    <span class="macro">println!</span>(<span class="string">"{}"</span>, text);

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</details>
<details>
<summary>Embedding powered search</summary>
<p>Once you have your data, Kalosm includes tools to create embedding-powered search indexes. Embedding-based search lets you find documents that are semantically similar to a specific word or phrase even if no words are an exact match:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>kalosm::language::<span class="kw-2">*</span>;
<span class="kw">use </span>surrealdb::{engine::local::SurrealKv, Surreal};

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
    <span class="comment">// Create database connection
    </span><span class="kw">let </span>db = Surreal::new::&lt;SurrealKv&gt;(std::env::temp_dir().join(<span class="string">"temp.db"</span>)).<span class="kw">await</span>.unwrap();

    <span class="comment">// Select a specific namespace / database
    </span>db.use_ns(<span class="string">"search"</span>).use_db(<span class="string">"documents"</span>).<span class="kw">await</span>.unwrap();

    <span class="comment">// Create a table in the surreal database to store the embeddings
    </span><span class="kw">let </span>document_table = db
        .document_table_builder(<span class="string">"documents"</span>)
        .build::&lt;Document&gt;()
        .<span class="kw">await
        </span>.unwrap();

    <span class="comment">// Add documents to the database
    </span>document_table.add_context(DocumentFolder::new(<span class="string">"./documents"</span>).unwrap()).<span class="kw">await</span>.unwrap();

    <span class="kw">loop </span>{
        <span class="comment">// Get the user's question
        </span><span class="kw">let </span>user_question = prompt_input(<span class="string">"Query: "</span>).unwrap();

        <span class="kw">let </span>nearest_5 = document_table
            .search(<span class="kw-2">&amp;</span>user_question)
            .with_results(<span class="number">5</span>)
            .<span class="kw">await
            </span>.unwrap();

        <span class="macro">println!</span>(<span class="string">"{:?}"</span>, nearest_5);
    }
}</code></pre></div>
</details>
<details>
<summary>Retrieval Augmented Generation</summary>
<p>A large part of making modern LLMs performant is curating the context the models have access to. Retrieval Augmented Generation (or RAG) helps you do this by inserting context into the prompt based on a search query. For example, you can Kalosm to create a chatbot that uses context from local documents to answer questions:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>kalosm::language::<span class="kw-2">*</span>;
<span class="kw">use </span>surrealdb::{engine::local::SurrealKv, Surreal};

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), anyhow::Error&gt; {
    <span class="kw">let </span>exists = std::path::Path::new(<span class="string">"./db"</span>).exists();

    <span class="comment">// Create database connection
    </span><span class="kw">let </span>db = Surreal::new::&lt;SurrealKv&gt;(<span class="string">"./db/temp.db"</span>).<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="comment">// Select a specific namespace / database
    </span>db.use_ns(<span class="string">"test"</span>).use_db(<span class="string">"test"</span>).<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="comment">// Create a table in the surreal database to store the embeddings
    </span><span class="kw">let </span>document_table = db
        .document_table_builder(<span class="string">"documents"</span>)
        .at(<span class="string">"./db/embeddings.db"</span>)
        .build::&lt;Document&gt;()
        .<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="comment">// If the database is new, add documents to it
    </span><span class="kw">if </span>!exists {
        std::fs::create_dir_all(<span class="string">"documents"</span>)<span class="question-mark">?</span>;
        <span class="kw">let </span>context = [
            <span class="string">"https://floneum.com/kalosm/docs"</span>,
            <span class="string">"https://floneum.com/kalosm/docs/guides/retrieval_augmented_generation"</span>,
        ]
        .iter()
        .map(|url| Url::parse(url).unwrap());

        document_table.add_context(context).<span class="kw">await</span><span class="question-mark">?</span>;
    }

    <span class="comment">// Create a llama chat model
    </span><span class="kw">let </span>model = Llama::new_chat().<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>chat = model.chat().with_system_prompt(<span class="string">"The assistant help answer questions based on the context given by the user. The model knows that the information the user gives it is always true."</span>);

    <span class="kw">loop </span>{
        <span class="comment">// Ask the user for a question
        </span><span class="kw">let </span>user_question = prompt_input(<span class="string">"\n&gt; "</span>)<span class="question-mark">?</span>;

        <span class="comment">// Search for relevant context in the document engine
        </span><span class="kw">let </span>context = document_table
            .search(<span class="kw-2">&amp;</span>user_question)
            .with_results(<span class="number">1</span>)
            .<span class="kw">await</span><span class="question-mark">?
            </span>.into_iter()
            .map(|document| {
                <span class="macro">format!</span>(
                    <span class="string">"Title: {}\nBody: {}\n"</span>,
                    document.record.title(),
                    document.record.body()
                )
            })
            .collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;()
            .join(<span class="string">"\n"</span>);

        <span class="comment">// Format a prompt with the question and context
        </span><span class="kw">let </span>prompt = <span class="macro">format!</span>(
            <span class="string">"{context}\n{user_question}"
        </span>);

        <span class="comment">// Display the prompt to the user for debugging purposes
        </span><span class="macro">println!</span>(<span class="string">"{}"</span>, prompt);

        <span class="comment">// And finally, respond to the user
        </span><span class="kw">let </span><span class="kw-2">mut </span>output_stream = chat(<span class="kw-2">&amp;</span>prompt);
        <span class="macro">print!</span>(<span class="string">"Bot: "</span>);
        output_stream.to_std_out().<span class="kw">await</span><span class="question-mark">?</span>;
    }
}</code></pre></div>
</details>
<details>
<summary>Live audio transcription</summary>
<p>Kalosm makes it easy to build up context about the world around your application.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>kalosm::sound::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), anyhow::Error&gt; {
    <span class="comment">// Create a new whisper model
    </span><span class="kw">let </span>model = Whisper::new().<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="comment">// Stream audio from the microphone
    </span><span class="kw">let </span>mic = MicInput::default();
    <span class="kw">let </span>stream = mic.stream();

    <span class="comment">// The audio into chunks based on voice activity and then transcribe those chunks
    // The model will transcribe chunks of speech that are separated by silence
    </span><span class="kw">let </span><span class="kw-2">mut </span>text_stream = stream.transcribe(model);

    <span class="comment">// Finally, print the text to the console
    </span>text_stream.to_std_out().<span class="kw">await</span>.unwrap();

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</details>
<details>
<summary>Image generation</summary>
<p>In addition to language, audio, and embedding models, Kalosm also supports image generation. For example, you can use Kalosm to generate images from text:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>kalosm::vision::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
    <span class="kw">let </span>model = Wuerstchen::new().<span class="kw">await</span>.unwrap();
    <span class="kw">let </span>settings = WuerstchenInferenceSettings::new(
        <span class="string">"a cute cat with a hat in a room covered with fur with incredible detail"</span>,
    );
    <span class="kw">let </span><span class="kw-2">mut </span>images = model.run(settings);
    <span class="kw">while let </span><span class="prelude-val">Some</span>(image) = images.next().<span class="kw">await </span>{
        <span class="kw">if let </span><span class="prelude-val">Some</span>(buf) = image.generated_image() {
            buf.save(<span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">"{}.png"</span>,image.sample_num())).unwrap();
        }
    }
}</code></pre></div>
</details>
<details>
<summary>Image segmentation</summary>
<p>Kalosm also supports image segmentation with the segment-anything model:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>kalosm::vision::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
    <span class="kw">let </span>model = SegmentAnything::builder().build().unwrap();
    <span class="kw">let </span>image = image::open(<span class="string">"examples/landscape.jpg"</span>).unwrap();
    <span class="kw">let </span>images = model.segment_everything(image).unwrap();
    <span class="kw">for </span>(i, img) <span class="kw">in </span>images.iter().enumerate() {
        img.save(<span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">"{}.png"</span>, i)).unwrap();
    }
}</code></pre></div>
</details></div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport._"><code>pub use futures_util::<a class="trait" href="language/trait.StreamExt.html" title="trait kalosm::language::StreamExt">StreamExt</a> as _;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="language/index.html" title="mod kalosm::language">language</a></dt><dd>Kalosm Language</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.BertDistance.html" title="struct kalosm::BertDistance">Bert<wbr>Distance</a></dt><dd>A metric that uses the Bert model to compute the distance between two strings.</dd><dt><a class="struct" href="struct.EvaluationResult.html" title="struct kalosm::EvaluationResult">Evaluation<wbr>Result</a></dt><dd>The result of evaluating a model using a set of test cases.</dd><dt><a class="struct" href="struct.TestCases.html" title="struct kalosm::TestCases">Test<wbr>Cases</a></dt><dd>A set of test cases to evaluate a model.</dd><dt><a class="struct" href="struct.WindowedStream.html" title="struct kalosm::WindowedStream">Windowed<wbr>Stream</a></dt><dd>A stream of time series data chunked into windows of a certain duration.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Metric.html" title="trait kalosm::Metric">Metric</a></dt><dd>A metric is a way to compare two pieces of data. It is used to evaluate the performance of a model.</dd><dt><a class="trait" href="trait.TimeSeriesStream.html" title="trait kalosm::TimeSeriesStream">Time<wbr>Series<wbr>Stream</a></dt><dd>A stream of time series data.</dd><dt><a class="trait" href="trait.TimeStamped.html" title="trait kalosm::TimeStamped">Time<wbr>Stamped</a></dt><dd>Something that has a timestamp attached to it.</dd></dl></section></div></main></body></html>