<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/Users/mariannegoldin/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/lmdb-master-sys-0.2.5/src/bindings.rs`."><title>bindings.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="lmdb_master_sys" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0 (17067e9ac 2025-05-09)" data-channel="1.87.0" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../../static.files/storage-82c7156e.js"></script><script defer src="../../static.files/src-script-63605ae7.js"></script><script defer src="../../src-files.js"></script><script defer src="../../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1><div class="sub-heading">lmdb_master_sys/</div>bindings.rs</h1><rustdoc-toolbar></rustdoc-toolbar></div><div class="example-wrap digits-3"><pre class="rust"><code><a href=#1 id=1 data-nosnippet>1</a><span class="comment">/* automatically generated by rust-bindgen 0.69.1 */
<a href=#2 id=2 data-nosnippet>2</a>
<a href=#3 id=3 data-nosnippet>3</a></span><span class="kw">pub const </span>MDB_FMT_Z: <span class="kw-2">&amp;</span>[u8; <span class="number">2</span>] = <span class="string">b"z\0"</span>;
<a href=#4 id=4 data-nosnippet>4</a><span class="kw">pub const </span>MDB_SIZE_MAX: u64 = <span class="number">18446744073709551615</span>;
<a href=#5 id=5 data-nosnippet>5</a><span class="kw">pub const </span>MDB_VERSION_MAJOR: ::libc::c_uint = <span class="number">0</span>;
<a href=#6 id=6 data-nosnippet>6</a><span class="kw">pub const </span>MDB_VERSION_MINOR: ::libc::c_uint = <span class="number">9</span>;
<a href=#7 id=7 data-nosnippet>7</a><span class="kw">pub const </span>MDB_VERSION_PATCH: ::libc::c_uint = <span class="number">70</span>;
<a href=#8 id=8 data-nosnippet>8</a><span class="kw">pub const </span>MDB_VERSION_DATE: <span class="kw-2">&amp;</span>[u8; <span class="number">18</span>] = <span class="string">b"December 19, 2015\0"</span>;
<a href=#9 id=9 data-nosnippet>9</a><span class="kw">pub const </span>MDB_FIXEDMAP: ::libc::c_uint = <span class="number">1</span>;
<a href=#10 id=10 data-nosnippet>10</a><span class="kw">pub const </span>MDB_NOSUBDIR: ::libc::c_uint = <span class="number">16384</span>;
<a href=#11 id=11 data-nosnippet>11</a><span class="kw">pub const </span>MDB_NOSYNC: ::libc::c_uint = <span class="number">65536</span>;
<a href=#12 id=12 data-nosnippet>12</a><span class="kw">pub const </span>MDB_RDONLY: ::libc::c_uint = <span class="number">131072</span>;
<a href=#13 id=13 data-nosnippet>13</a><span class="kw">pub const </span>MDB_NOMETASYNC: ::libc::c_uint = <span class="number">262144</span>;
<a href=#14 id=14 data-nosnippet>14</a><span class="kw">pub const </span>MDB_WRITEMAP: ::libc::c_uint = <span class="number">524288</span>;
<a href=#15 id=15 data-nosnippet>15</a><span class="kw">pub const </span>MDB_MAPASYNC: ::libc::c_uint = <span class="number">1048576</span>;
<a href=#16 id=16 data-nosnippet>16</a><span class="kw">pub const </span>MDB_NOTLS: ::libc::c_uint = <span class="number">2097152</span>;
<a href=#17 id=17 data-nosnippet>17</a><span class="kw">pub const </span>MDB_NOLOCK: ::libc::c_uint = <span class="number">4194304</span>;
<a href=#18 id=18 data-nosnippet>18</a><span class="kw">pub const </span>MDB_NORDAHEAD: ::libc::c_uint = <span class="number">8388608</span>;
<a href=#19 id=19 data-nosnippet>19</a><span class="kw">pub const </span>MDB_NOMEMINIT: ::libc::c_uint = <span class="number">16777216</span>;
<a href=#20 id=20 data-nosnippet>20</a><span class="kw">pub const </span>MDB_PREVSNAPSHOT: ::libc::c_uint = <span class="number">33554432</span>;
<a href=#21 id=21 data-nosnippet>21</a><span class="kw">pub const </span>MDB_REVERSEKEY: ::libc::c_uint = <span class="number">2</span>;
<a href=#22 id=22 data-nosnippet>22</a><span class="kw">pub const </span>MDB_DUPSORT: ::libc::c_uint = <span class="number">4</span>;
<a href=#23 id=23 data-nosnippet>23</a><span class="kw">pub const </span>MDB_INTEGERKEY: ::libc::c_uint = <span class="number">8</span>;
<a href=#24 id=24 data-nosnippet>24</a><span class="kw">pub const </span>MDB_DUPFIXED: ::libc::c_uint = <span class="number">16</span>;
<a href=#25 id=25 data-nosnippet>25</a><span class="kw">pub const </span>MDB_INTEGERDUP: ::libc::c_uint = <span class="number">32</span>;
<a href=#26 id=26 data-nosnippet>26</a><span class="kw">pub const </span>MDB_REVERSEDUP: ::libc::c_uint = <span class="number">64</span>;
<a href=#27 id=27 data-nosnippet>27</a><span class="kw">pub const </span>MDB_CREATE: ::libc::c_uint = <span class="number">262144</span>;
<a href=#28 id=28 data-nosnippet>28</a><span class="kw">pub const </span>MDB_NOOVERWRITE: ::libc::c_uint = <span class="number">16</span>;
<a href=#29 id=29 data-nosnippet>29</a><span class="kw">pub const </span>MDB_NODUPDATA: ::libc::c_uint = <span class="number">32</span>;
<a href=#30 id=30 data-nosnippet>30</a><span class="kw">pub const </span>MDB_CURRENT: ::libc::c_uint = <span class="number">64</span>;
<a href=#31 id=31 data-nosnippet>31</a><span class="kw">pub const </span>MDB_RESERVE: ::libc::c_uint = <span class="number">65536</span>;
<a href=#32 id=32 data-nosnippet>32</a><span class="kw">pub const </span>MDB_APPEND: ::libc::c_uint = <span class="number">131072</span>;
<a href=#33 id=33 data-nosnippet>33</a><span class="kw">pub const </span>MDB_APPENDDUP: ::libc::c_uint = <span class="number">262144</span>;
<a href=#34 id=34 data-nosnippet>34</a><span class="kw">pub const </span>MDB_MULTIPLE: ::libc::c_uint = <span class="number">524288</span>;
<a href=#35 id=35 data-nosnippet>35</a><span class="kw">pub const </span>MDB_CP_COMPACT: ::libc::c_uint = <span class="number">1</span>;
<a href=#36 id=36 data-nosnippet>36</a><span class="kw">pub const </span>MDB_SUCCESS: ::libc::c_int = <span class="number">0</span>;
<a href=#37 id=37 data-nosnippet>37</a><span class="kw">pub const </span>MDB_KEYEXIST: ::libc::c_int = -<span class="number">30799</span>;
<a href=#38 id=38 data-nosnippet>38</a><span class="kw">pub const </span>MDB_NOTFOUND: ::libc::c_int = -<span class="number">30798</span>;
<a href=#39 id=39 data-nosnippet>39</a><span class="kw">pub const </span>MDB_PAGE_NOTFOUND: ::libc::c_int = -<span class="number">30797</span>;
<a href=#40 id=40 data-nosnippet>40</a><span class="kw">pub const </span>MDB_CORRUPTED: ::libc::c_int = -<span class="number">30796</span>;
<a href=#41 id=41 data-nosnippet>41</a><span class="kw">pub const </span>MDB_PANIC: ::libc::c_int = -<span class="number">30795</span>;
<a href=#42 id=42 data-nosnippet>42</a><span class="kw">pub const </span>MDB_VERSION_MISMATCH: ::libc::c_int = -<span class="number">30794</span>;
<a href=#43 id=43 data-nosnippet>43</a><span class="kw">pub const </span>MDB_INVALID: ::libc::c_int = -<span class="number">30793</span>;
<a href=#44 id=44 data-nosnippet>44</a><span class="kw">pub const </span>MDB_MAP_FULL: ::libc::c_int = -<span class="number">30792</span>;
<a href=#45 id=45 data-nosnippet>45</a><span class="kw">pub const </span>MDB_DBS_FULL: ::libc::c_int = -<span class="number">30791</span>;
<a href=#46 id=46 data-nosnippet>46</a><span class="kw">pub const </span>MDB_READERS_FULL: ::libc::c_int = -<span class="number">30790</span>;
<a href=#47 id=47 data-nosnippet>47</a><span class="kw">pub const </span>MDB_TLS_FULL: ::libc::c_int = -<span class="number">30789</span>;
<a href=#48 id=48 data-nosnippet>48</a><span class="kw">pub const </span>MDB_TXN_FULL: ::libc::c_int = -<span class="number">30788</span>;
<a href=#49 id=49 data-nosnippet>49</a><span class="kw">pub const </span>MDB_CURSOR_FULL: ::libc::c_int = -<span class="number">30787</span>;
<a href=#50 id=50 data-nosnippet>50</a><span class="kw">pub const </span>MDB_PAGE_FULL: ::libc::c_int = -<span class="number">30786</span>;
<a href=#51 id=51 data-nosnippet>51</a><span class="kw">pub const </span>MDB_MAP_RESIZED: ::libc::c_int = -<span class="number">30785</span>;
<a href=#52 id=52 data-nosnippet>52</a><span class="kw">pub const </span>MDB_INCOMPATIBLE: ::libc::c_int = -<span class="number">30784</span>;
<a href=#53 id=53 data-nosnippet>53</a><span class="kw">pub const </span>MDB_BAD_RSLOT: ::libc::c_int = -<span class="number">30783</span>;
<a href=#54 id=54 data-nosnippet>54</a><span class="kw">pub const </span>MDB_BAD_TXN: ::libc::c_int = -<span class="number">30782</span>;
<a href=#55 id=55 data-nosnippet>55</a><span class="kw">pub const </span>MDB_BAD_VALSIZE: ::libc::c_int = -<span class="number">30781</span>;
<a href=#56 id=56 data-nosnippet>56</a><span class="kw">pub const </span>MDB_BAD_DBI: ::libc::c_int = -<span class="number">30780</span>;
<a href=#57 id=57 data-nosnippet>57</a><span class="kw">pub const </span>MDB_PROBLEM: ::libc::c_int = -<span class="number">30779</span>;
<a href=#58 id=58 data-nosnippet>58</a><span class="kw">pub const </span>MDB_LAST_ERRCODE: ::libc::c_int = -<span class="number">30779</span>;
<a href=#59 id=59 data-nosnippet>59</a><span class="attr">#[doc = <span class="string">"Unsigned type used for mapsize, entry counts and page/transaction IDs.\n\n\tIt is normally size_t, hence the name. Defining MDB_VL32 makes it\n\tuint64_t, but do not try this unless you know what you are doing."</span>]
<a href=#60 id=60 data-nosnippet>60</a></span><span class="kw">pub type </span>mdb_size_t = usize;
<a href=#61 id=61 data-nosnippet>61</a><span class="attr">#[repr(C)]
<a href=#62 id=62 data-nosnippet>62</a>#[derive(Debug, Copy, Clone)]
<a href=#63 id=63 data-nosnippet>63</a></span><span class="kw">pub struct </span>MDB_env {
<a href=#64 id=64 data-nosnippet>64</a>    _unused: [u8; <span class="number">0</span>],
<a href=#65 id=65 data-nosnippet>65</a>}
<a href=#66 id=66 data-nosnippet>66</a><span class="attr">#[repr(C)]
<a href=#67 id=67 data-nosnippet>67</a>#[derive(Debug, Copy, Clone)]
<a href=#68 id=68 data-nosnippet>68</a></span><span class="kw">pub struct </span>MDB_txn {
<a href=#69 id=69 data-nosnippet>69</a>    _unused: [u8; <span class="number">0</span>],
<a href=#70 id=70 data-nosnippet>70</a>}
<a href=#71 id=71 data-nosnippet>71</a><span class="attr">#[doc = <span class="string">"A handle for an individual database in the DB environment."</span>]
<a href=#72 id=72 data-nosnippet>72</a></span><span class="kw">pub type </span>MDB_dbi = ::libc::c_uint;
<a href=#73 id=73 data-nosnippet>73</a><span class="attr">#[repr(C)]
<a href=#74 id=74 data-nosnippet>74</a>#[derive(Debug, Copy, Clone)]
<a href=#75 id=75 data-nosnippet>75</a></span><span class="kw">pub struct </span>MDB_cursor {
<a href=#76 id=76 data-nosnippet>76</a>    _unused: [u8; <span class="number">0</span>],
<a href=#77 id=77 data-nosnippet>77</a>}
<a href=#78 id=78 data-nosnippet>78</a><span class="attr">#[doc = <span class="string">"Generic structure used for passing keys and data in and out\n of the database.\n\n Values returned from the database are valid only until a subsequent\n update operation, or the end of the transaction. Do not modify or\n free them, they commonly point into the database itself.\n\n Key sizes must be between 1 and #mdb_env_get_maxkeysize() inclusive.\n The same applies to data sizes in databases with the #MDB_DUPSORT flag.\n Other data items can in theory be from 0 to 0xffffffff bytes long."</span>]
<a href=#79 id=79 data-nosnippet>79</a>#[repr(C)]
<a href=#80 id=80 data-nosnippet>80</a>#[derive(Debug, Copy, Clone)]
<a href=#81 id=81 data-nosnippet>81</a></span><span class="kw">pub struct </span>MDB_val {
<a href=#82 id=82 data-nosnippet>82</a>    <span class="attr">#[doc = <span class="string">"&lt; size of the data item"</span>]
<a href=#83 id=83 data-nosnippet>83</a>    </span><span class="kw">pub </span>mv_size: usize,
<a href=#84 id=84 data-nosnippet>84</a>    <span class="attr">#[doc = <span class="string">"&lt; address of the data item"</span>]
<a href=#85 id=85 data-nosnippet>85</a>    </span><span class="kw">pub </span>mv_data: <span class="kw-2">*mut </span>::libc::c_void,
<a href=#86 id=86 data-nosnippet>86</a>}
<a href=#87 id=87 data-nosnippet>87</a><span class="attr">#[doc = <span class="string">"A callback function used to compare two keys in a database"</span>]
<a href=#88 id=88 data-nosnippet>88</a></span><span class="kw">pub type </span>MDB_cmp_func = ::std::option::Option&lt;
<a href=#89 id=89 data-nosnippet>89</a>    <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(a: <span class="kw-2">*const </span>MDB_val, b: <span class="kw-2">*const </span>MDB_val) -&gt; ::libc::c_int,
<a href=#90 id=90 data-nosnippet>90</a>&gt;;
<a href=#91 id=91 data-nosnippet>91</a><span class="attr">#[doc = <span class="string">"A callback function used to relocate a position-dependent data item\n in a fixed-address database.\n\n The **newptr** gives the item's desired address in\n the memory map, and **oldptr** gives its previous address. The item's actual\n data resides at the address in **item.** This callback is expected to walk\n through the fields of the record in **item** and modify any\n values based at the **oldptr** address to be relative to the **newptr** address.\n # Arguments\n\n* `item` (direction in, out) - The item that is to be relocated.\n * `oldptr` (direction in) - The previous address.\n * `newptr` (direction in) - The new address to relocate to.\n * `relctx` (direction in) - An application-provided context, set by #mdb_set_relctx().\n This feature is currently unimplemented."</span>]
<a href=#92 id=92 data-nosnippet>92</a></span><span class="kw">pub type </span>MDB_rel_func = ::std::option::Option&lt;
<a href=#93 id=93 data-nosnippet>93</a>    <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(
<a href=#94 id=94 data-nosnippet>94</a>        item: <span class="kw-2">*mut </span>MDB_val,
<a href=#95 id=95 data-nosnippet>95</a>        oldptr: <span class="kw-2">*mut </span>::libc::c_void,
<a href=#96 id=96 data-nosnippet>96</a>        newptr: <span class="kw-2">*mut </span>::libc::c_void,
<a href=#97 id=97 data-nosnippet>97</a>        relctx: <span class="kw-2">*mut </span>::libc::c_void,
<a href=#98 id=98 data-nosnippet>98</a>    ),
<a href=#99 id=99 data-nosnippet>99</a>&gt;;
<a href=#100 id=100 data-nosnippet>100</a><span class="attr">#[doc = <span class="string">"&lt; Position at first key/data item"</span>]
<a href=#101 id=101 data-nosnippet>101</a></span><span class="kw">pub const </span>MDB_FIRST: MDB_cursor_op = <span class="number">0</span>;
<a href=#102 id=102 data-nosnippet>102</a><span class="attr">#[doc = <span class="string">"&lt; Position at first data item of current key.\nOnly for #MDB_DUPSORT"</span>]
<a href=#103 id=103 data-nosnippet>103</a></span><span class="kw">pub const </span>MDB_FIRST_DUP: MDB_cursor_op = <span class="number">1</span>;
<a href=#104 id=104 data-nosnippet>104</a><span class="attr">#[doc = <span class="string">"&lt; Position at key/data pair. Only for #MDB_DUPSORT"</span>]
<a href=#105 id=105 data-nosnippet>105</a></span><span class="kw">pub const </span>MDB_GET_BOTH: MDB_cursor_op = <span class="number">2</span>;
<a href=#106 id=106 data-nosnippet>106</a><span class="attr">#[doc = <span class="string">"&lt; position at key, nearest data. Only for #MDB_DUPSORT"</span>]
<a href=#107 id=107 data-nosnippet>107</a></span><span class="kw">pub const </span>MDB_GET_BOTH_RANGE: MDB_cursor_op = <span class="number">3</span>;
<a href=#108 id=108 data-nosnippet>108</a><span class="attr">#[doc = <span class="string">"&lt; Return key/data at current cursor position"</span>]
<a href=#109 id=109 data-nosnippet>109</a></span><span class="kw">pub const </span>MDB_GET_CURRENT: MDB_cursor_op = <span class="number">4</span>;
<a href=#110 id=110 data-nosnippet>110</a><span class="attr">#[doc = <span class="string">"&lt; Return up to a page of duplicate data items\nfrom current cursor position. Move cursor to prepare\nfor #MDB_NEXT_MULTIPLE. Only for #MDB_DUPFIXED"</span>]
<a href=#111 id=111 data-nosnippet>111</a></span><span class="kw">pub const </span>MDB_GET_MULTIPLE: MDB_cursor_op = <span class="number">5</span>;
<a href=#112 id=112 data-nosnippet>112</a><span class="attr">#[doc = <span class="string">"&lt; Position at last key/data item"</span>]
<a href=#113 id=113 data-nosnippet>113</a></span><span class="kw">pub const </span>MDB_LAST: MDB_cursor_op = <span class="number">6</span>;
<a href=#114 id=114 data-nosnippet>114</a><span class="attr">#[doc = <span class="string">"&lt; Position at last data item of current key.\nOnly for #MDB_DUPSORT"</span>]
<a href=#115 id=115 data-nosnippet>115</a></span><span class="kw">pub const </span>MDB_LAST_DUP: MDB_cursor_op = <span class="number">7</span>;
<a href=#116 id=116 data-nosnippet>116</a><span class="attr">#[doc = <span class="string">"&lt; Position at next data item"</span>]
<a href=#117 id=117 data-nosnippet>117</a></span><span class="kw">pub const </span>MDB_NEXT: MDB_cursor_op = <span class="number">8</span>;
<a href=#118 id=118 data-nosnippet>118</a><span class="attr">#[doc = <span class="string">"&lt; Position at next data item of current key.\nOnly for #MDB_DUPSORT"</span>]
<a href=#119 id=119 data-nosnippet>119</a></span><span class="kw">pub const </span>MDB_NEXT_DUP: MDB_cursor_op = <span class="number">9</span>;
<a href=#120 id=120 data-nosnippet>120</a><span class="attr">#[doc = <span class="string">"&lt; Return up to a page of duplicate data items\nfrom next cursor position. Move cursor to prepare\nfor #MDB_NEXT_MULTIPLE. Only for #MDB_DUPFIXED"</span>]
<a href=#121 id=121 data-nosnippet>121</a></span><span class="kw">pub const </span>MDB_NEXT_MULTIPLE: MDB_cursor_op = <span class="number">10</span>;
<a href=#122 id=122 data-nosnippet>122</a><span class="attr">#[doc = <span class="string">"&lt; Position at first data item of next key"</span>]
<a href=#123 id=123 data-nosnippet>123</a></span><span class="kw">pub const </span>MDB_NEXT_NODUP: MDB_cursor_op = <span class="number">11</span>;
<a href=#124 id=124 data-nosnippet>124</a><span class="attr">#[doc = <span class="string">"&lt; Position at previous data item"</span>]
<a href=#125 id=125 data-nosnippet>125</a></span><span class="kw">pub const </span>MDB_PREV: MDB_cursor_op = <span class="number">12</span>;
<a href=#126 id=126 data-nosnippet>126</a><span class="attr">#[doc = <span class="string">"&lt; Position at previous data item of current key.\nOnly for #MDB_DUPSORT"</span>]
<a href=#127 id=127 data-nosnippet>127</a></span><span class="kw">pub const </span>MDB_PREV_DUP: MDB_cursor_op = <span class="number">13</span>;
<a href=#128 id=128 data-nosnippet>128</a><span class="attr">#[doc = <span class="string">"&lt; Position at last data item of previous key"</span>]
<a href=#129 id=129 data-nosnippet>129</a></span><span class="kw">pub const </span>MDB_PREV_NODUP: MDB_cursor_op = <span class="number">14</span>;
<a href=#130 id=130 data-nosnippet>130</a><span class="attr">#[doc = <span class="string">"&lt; Position at specified key"</span>]
<a href=#131 id=131 data-nosnippet>131</a></span><span class="kw">pub const </span>MDB_SET: MDB_cursor_op = <span class="number">15</span>;
<a href=#132 id=132 data-nosnippet>132</a><span class="attr">#[doc = <span class="string">"&lt; Position at specified key, return key + data"</span>]
<a href=#133 id=133 data-nosnippet>133</a></span><span class="kw">pub const </span>MDB_SET_KEY: MDB_cursor_op = <span class="number">16</span>;
<a href=#134 id=134 data-nosnippet>134</a><span class="attr">#[doc = <span class="string">"&lt; Position at first key greater than or equal to specified key."</span>]
<a href=#135 id=135 data-nosnippet>135</a></span><span class="kw">pub const </span>MDB_SET_RANGE: MDB_cursor_op = <span class="number">17</span>;
<a href=#136 id=136 data-nosnippet>136</a><span class="attr">#[doc = <span class="string">"&lt; Position at previous page and return up to\na page of duplicate data items. Only for #MDB_DUPFIXED"</span>]
<a href=#137 id=137 data-nosnippet>137</a></span><span class="kw">pub const </span>MDB_PREV_MULTIPLE: MDB_cursor_op = <span class="number">18</span>;
<a href=#138 id=138 data-nosnippet>138</a><span class="attr">#[doc = <span class="string">"Cursor Get operations.\n\n\tThis is the set of all operations for retrieving data\n\tusing a cursor."</span>]
<a href=#139 id=139 data-nosnippet>139</a></span><span class="kw">pub type </span>MDB_cursor_op = ::libc::c_uint;
<a href=#140 id=140 data-nosnippet>140</a><span class="attr">#[doc = <span class="string">"Statistics for a database in the environment"</span>]
<a href=#141 id=141 data-nosnippet>141</a>#[repr(C)]
<a href=#142 id=142 data-nosnippet>142</a>#[derive(Debug, Copy, Clone)]
<a href=#143 id=143 data-nosnippet>143</a></span><span class="kw">pub struct </span>MDB_stat {
<a href=#144 id=144 data-nosnippet>144</a>    <span class="attr">#[doc = <span class="string">"&lt; Size of a database page.\nThis is currently the same for all databases."</span>]
<a href=#145 id=145 data-nosnippet>145</a>    </span><span class="kw">pub </span>ms_psize: ::libc::c_uint,
<a href=#146 id=146 data-nosnippet>146</a>    <span class="attr">#[doc = <span class="string">"&lt; Depth (height) of the B-tree"</span>]
<a href=#147 id=147 data-nosnippet>147</a>    </span><span class="kw">pub </span>ms_depth: ::libc::c_uint,
<a href=#148 id=148 data-nosnippet>148</a>    <span class="attr">#[doc = <span class="string">"&lt; Number of internal (non-leaf) pages"</span>]
<a href=#149 id=149 data-nosnippet>149</a>    </span><span class="kw">pub </span>ms_branch_pages: mdb_size_t,
<a href=#150 id=150 data-nosnippet>150</a>    <span class="attr">#[doc = <span class="string">"&lt; Number of leaf pages"</span>]
<a href=#151 id=151 data-nosnippet>151</a>    </span><span class="kw">pub </span>ms_leaf_pages: mdb_size_t,
<a href=#152 id=152 data-nosnippet>152</a>    <span class="attr">#[doc = <span class="string">"&lt; Number of overflow pages"</span>]
<a href=#153 id=153 data-nosnippet>153</a>    </span><span class="kw">pub </span>ms_overflow_pages: mdb_size_t,
<a href=#154 id=154 data-nosnippet>154</a>    <span class="attr">#[doc = <span class="string">"&lt; Number of data items"</span>]
<a href=#155 id=155 data-nosnippet>155</a>    </span><span class="kw">pub </span>ms_entries: mdb_size_t,
<a href=#156 id=156 data-nosnippet>156</a>}
<a href=#157 id=157 data-nosnippet>157</a><span class="attr">#[doc = <span class="string">"Information about the environment"</span>]
<a href=#158 id=158 data-nosnippet>158</a>#[repr(C)]
<a href=#159 id=159 data-nosnippet>159</a>#[derive(Debug, Copy, Clone)]
<a href=#160 id=160 data-nosnippet>160</a></span><span class="kw">pub struct </span>MDB_envinfo {
<a href=#161 id=161 data-nosnippet>161</a>    <span class="attr">#[doc = <span class="string">"&lt; Address of map, if fixed"</span>]
<a href=#162 id=162 data-nosnippet>162</a>    </span><span class="kw">pub </span>me_mapaddr: <span class="kw-2">*mut </span>::libc::c_void,
<a href=#163 id=163 data-nosnippet>163</a>    <span class="attr">#[doc = <span class="string">"&lt; Size of the data memory map"</span>]
<a href=#164 id=164 data-nosnippet>164</a>    </span><span class="kw">pub </span>me_mapsize: mdb_size_t,
<a href=#165 id=165 data-nosnippet>165</a>    <span class="attr">#[doc = <span class="string">"&lt; ID of the last used page"</span>]
<a href=#166 id=166 data-nosnippet>166</a>    </span><span class="kw">pub </span>me_last_pgno: mdb_size_t,
<a href=#167 id=167 data-nosnippet>167</a>    <span class="attr">#[doc = <span class="string">"&lt; ID of the last committed transaction"</span>]
<a href=#168 id=168 data-nosnippet>168</a>    </span><span class="kw">pub </span>me_last_txnid: mdb_size_t,
<a href=#169 id=169 data-nosnippet>169</a>    <span class="attr">#[doc = <span class="string">"&lt; max reader slots in the environment"</span>]
<a href=#170 id=170 data-nosnippet>170</a>    </span><span class="kw">pub </span>me_maxreaders: ::libc::c_uint,
<a href=#171 id=171 data-nosnippet>171</a>    <span class="attr">#[doc = <span class="string">"&lt; max reader slots used in the environment"</span>]
<a href=#172 id=172 data-nosnippet>172</a>    </span><span class="kw">pub </span>me_numreaders: ::libc::c_uint,
<a href=#173 id=173 data-nosnippet>173</a>}
<a href=#174 id=174 data-nosnippet>174</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#175 id=175 data-nosnippet>175</a>    <span class="attr">#[doc = <span class="string">"Return the LMDB library version information.\n\n # Arguments\n\n* `major` (direction out) - if non-NULL, the library major version number is copied here\n * `minor` (direction out) - if non-NULL, the library minor version number is copied here\n * `patch` (direction out) - if non-NULL, the library patch version number is copied here\n # Returns\n\n* `\"version` - string\" The library version as a string"</span>]
<a href=#176 id=176 data-nosnippet>176</a>    </span><span class="kw">pub fn </span>mdb_version(
<a href=#177 id=177 data-nosnippet>177</a>        major: <span class="kw-2">*mut </span>::libc::c_int,
<a href=#178 id=178 data-nosnippet>178</a>        minor: <span class="kw-2">*mut </span>::libc::c_int,
<a href=#179 id=179 data-nosnippet>179</a>        patch: <span class="kw-2">*mut </span>::libc::c_int,
<a href=#180 id=180 data-nosnippet>180</a>    ) -&gt; <span class="kw-2">*mut </span>::libc::c_char;
<a href=#181 id=181 data-nosnippet>181</a>}
<a href=#182 id=182 data-nosnippet>182</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#183 id=183 data-nosnippet>183</a>    <span class="attr">#[doc = <span class="string">"Return a string describing a given error code.\n\n This function is a superset of the ANSI C X3.159-1989 (ANSI C) strerror(3)\n function. If the error code is greater than or equal to 0, then the string\n returned by the system function strerror(3) is returned. If the error code\n is less than 0, an error string corresponding to the LMDB library error is\n returned. See errors for a list of LMDB-specific error codes.\n # Arguments\n\n* `err` (direction in) - The error code\n # Returns\n\n* `\"error` - message\" The description of the error"</span>]
<a href=#184 id=184 data-nosnippet>184</a>    </span><span class="kw">pub fn </span>mdb_strerror(err: ::libc::c_int) -&gt; <span class="kw-2">*mut </span>::libc::c_char;
<a href=#185 id=185 data-nosnippet>185</a>}
<a href=#186 id=186 data-nosnippet>186</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#187 id=187 data-nosnippet>187</a>    <span class="attr">#[doc = <span class="string">"Create an LMDB environment handle.\n\n This function allocates memory for a #MDB_env structure. To release\n the allocated memory and discard the handle, call #mdb_env_close().\n Before the handle may be used, it must be opened using #mdb_env_open().\n Various other options may also need to be set before opening the handle,\n e.g. #mdb_env_set_mapsize(), #mdb_env_set_maxreaders(), #mdb_env_set_maxdbs(),\n depending on usage requirements.\n # Arguments\n\n* `env` (direction out) - The address where the new handle will be stored\n # Returns\n\nA non-zero error value on failure and 0 on success."</span>]
<a href=#188 id=188 data-nosnippet>188</a>    </span><span class="kw">pub fn </span>mdb_env_create(env: <span class="kw-2">*mut *mut </span>MDB_env) -&gt; ::libc::c_int;
<a href=#189 id=189 data-nosnippet>189</a>}
<a href=#190 id=190 data-nosnippet>190</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#191 id=191 data-nosnippet>191</a>    <span class="attr">#[doc = <span class="string">"Open an environment handle.\n\n If this function fails, #mdb_env_close() must be called to discard the #MDB_env handle.\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create()\n * `path` (direction in) - The directory in which the database files reside. This\n directory must already exist and be writable.\n * `flags` (direction in) - Special options for this environment. This parameter\n must be set to 0 or by bitwise OR'ing together one or more of the\n values described here.\n Flags set by mdb_env_set_flags() are also used.\n &lt;ul&gt;\n\t&lt;li&gt;#MDB_FIXEDMAP\n use a fixed address for the mmap region. This flag must be specified\n when creating the environment, and is stored persistently in the environment.\n\t\tIf successful, the memory map will always reside at the same virtual address\n\t\tand pointers used to reference data items in the database will be constant\n\t\tacross multiple invocations. This option may not always work, depending on\n\t\thow the operating system has allocated memory to shared libraries and other uses.\n\t\tThe feature is highly experimental.\n\t&lt;li&gt;#MDB_NOSUBDIR\n\t\tBy default, LMDB creates its environment in a directory whose\n\t\tpathname is given in **path,** and creates its data and lock files\n\t\tunder that directory. With this option, **path** is used as-is for\n\t\tthe database main data file. The database lock file is the **path**\n\t\twith \"-lock\" appended.\n\t&lt;li&gt;#MDB_RDONLY\n\t\tOpen the environment in read-only mode. No write operations will be\n\t\tallowed. LMDB will still modify the lock file - except on read-only\n\t\tfilesystems, where LMDB does not use locks.\n\t&lt;li&gt;#MDB_WRITEMAP\n\t\tUse a writeable memory map unless MDB_RDONLY is set. This uses\n\t\tfewer mallocs but loses protection from application bugs\n\t\tlike wild pointer writes and other bad updates into the database.\n\t\tThis may be slightly faster for DBs that fit entirely in RAM, but\n\t\tis slower for DBs larger than RAM.\n\t\tIncompatible with nested transactions.\n\t\tDo not mix processes with and without MDB_WRITEMAP on the same\n\t\tenvironment. This can defeat durability (#mdb_env_sync etc).\n\t&lt;li&gt;#MDB_NOMETASYNC\n\t\tFlush system buffers to disk only once per transaction, omit the\n\t\tmetadata flush. Defer that until the system flushes files to disk,\n\t\tor next non-MDB_RDONLY commit or #mdb_env_sync(). This optimization\n\t\tmaintains database integrity, but a system crash may undo the last\n\t\tcommitted transaction. I.e. it preserves the ACI (atomicity,\n\t\tconsistency, isolation) but not D (durability) database property.\n\t\tThis flag may be changed at any time using #mdb_env_set_flags().\n\t&lt;li&gt;#MDB_NOSYNC\n\t\tDon't flush system buffers to disk when committing a transaction.\n\t\tThis optimization means a system crash can corrupt the database or\n\t\tlose the last transactions if buffers are not yet flushed to disk.\n\t\tThe risk is governed by how often the system flushes dirty buffers\n\t\tto disk and how often #mdb_env_sync() is called. However, if the\n\t\tfilesystem preserves write order and the #MDB_WRITEMAP flag is not\n\t\tused, transactions exhibit ACI (atomicity, consistency, isolation)\n\t\tproperties and only lose D (durability). I.e. database integrity\n\t\tis maintained, but a system crash may undo the final transactions.\n\t\tNote that (#MDB_NOSYNC | #MDB_WRITEMAP) leaves the system with no\n\t\thint for when to write transactions to disk, unless #mdb_env_sync()\n\t\tis called. (#MDB_MAPASYNC | #MDB_WRITEMAP) may be preferable.\n\t\tThis flag may be changed at any time using #mdb_env_set_flags().\n\t&lt;li&gt;#MDB_MAPASYNC\n\t\tWhen using #MDB_WRITEMAP, use asynchronous flushes to disk.\n\t\tAs with #MDB_NOSYNC, a system crash can then corrupt the\n\t\tdatabase or lose the last transactions. Calling #mdb_env_sync()\n\t\tensures on-disk database integrity until next commit.\n\t\tThis flag may be changed at any time using #mdb_env_set_flags().\n\t&lt;li&gt;#MDB_NOTLS\n\t\tDon't use Thread-Local Storage. Tie reader locktable slots to\n\t\t#MDB_txn objects instead of to threads. I.e. #mdb_txn_reset() keeps\n\t\tthe slot reserved for the #MDB_txn object. A thread may use parallel\n\t\tread-only transactions. A read-only transaction may span threads if\n\t\tthe user synchronizes its use. Applications that multiplex many\n\t\tuser threads over individual OS threads need this option. Such an\n\t\tapplication must also serialize the write transactions in an OS\n\t\tthread, since LMDB's write locking is unaware of the user threads.\n\t&lt;li&gt;#MDB_NOLOCK\n\t\tDon't do any locking. If concurrent access is anticipated, the\n\t\tcaller must manage all concurrency itself. For proper operation\n\t\tthe caller must enforce single-writer semantics, and must ensure\n\t\tthat no readers are using old transactions while a writer is\n\t\tactive. The simplest approach is to use an exclusive lock so that\n\t\tno readers may be active at all when a writer begins.\n\t&lt;li&gt;#MDB_NORDAHEAD\n\t\tTurn off readahead. Most operating systems perform readahead on\n\t\tread requests by default. This option turns it off if the OS\n\t\tsupports it. Turning it off may help random read performance\n\t\twhen the DB is larger than RAM and system RAM is full.\n\t\tThe option is not implemented on Windows.\n\t&lt;li&gt;#MDB_NOMEMINIT\n\t\tDon't initialize malloc'd memory before writing to unused spaces\n\t\tin the data file. By default, memory for pages written to the data\n\t\tfile is obtained using malloc. While these pages may be reused in\n\t\tsubsequent transactions, freshly malloc'd pages will be initialized\n\t\tto zeroes before use. This avoids persisting leftover data from other\n\t\tcode (that used the heap and subsequently freed the memory) into the\n\t\tdata file. Note that many other system libraries may allocate\n\t\tand free memory from the heap for arbitrary uses. E.g., stdio may\n\t\tuse the heap for file I/O buffers. This initialization step has a\n\t\tmodest performance cost so some applications may want to disable\n\t\tit using this flag. This option can be a problem for applications\n\t\twhich handle sensitive data like passwords, and it makes memory\n\t\tcheckers like Valgrind noisy. This flag is not needed with #MDB_WRITEMAP,\n\t\twhich writes directly to the mmap instead of using malloc for pages. The\n\t\tinitialization is also skipped if #MDB_RESERVE is used; the\n\t\tcaller is expected to overwrite all of the memory that was\n\t\treserved in that case.\n\t\tThis flag may be changed at any time using #mdb_env_set_flags().\n\t&lt;li&gt;#MDB_PREVSNAPSHOT\n\t\tOpen the environment with the previous snapshot rather than the latest\n\t\tone. This loses the latest transaction, but may help work around some\n\t\ttypes of corruption. If opened with write access, this must be the\n\t\tonly process using the environment. This flag is automatically reset\n\t\tafter a write transaction is successfully committed.\n &lt;/ul&gt;\n * `mode` (direction in) - The UNIX permissions to set on created files and semaphores.\n This parameter is ignored on Windows.\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;#MDB_VERSION_MISMATCH - the version of the LMDB library doesn't match the\n\tversion that created the database environment.\n\t&lt;li&gt;#MDB_INVALID - the environment file headers are corrupted.\n\t&lt;li&gt;ENOENT - the directory specified by the path parameter doesn't exist.\n\t&lt;li&gt;EACCES - the user didn't have permission to access the environment files.\n\t&lt;li&gt;EAGAIN - the environment was locked by another process.\n &lt;/ul&gt;"</span>]
<a href=#192 id=192 data-nosnippet>192</a>    </span><span class="kw">pub fn </span>mdb_env_open(
<a href=#193 id=193 data-nosnippet>193</a>        env: <span class="kw-2">*mut </span>MDB_env,
<a href=#194 id=194 data-nosnippet>194</a>        path: <span class="kw-2">*const </span>::libc::c_char,
<a href=#195 id=195 data-nosnippet>195</a>        flags: ::libc::c_uint,
<a href=#196 id=196 data-nosnippet>196</a>        mode: mdb_mode_t,
<a href=#197 id=197 data-nosnippet>197</a>    ) -&gt; ::libc::c_int;
<a href=#198 id=198 data-nosnippet>198</a>}
<a href=#199 id=199 data-nosnippet>199</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#200 id=200 data-nosnippet>200</a>    <span class="attr">#[doc = <span class="string">"Copy an LMDB environment to the specified path.\n\n This function may be used to make a backup of an existing environment.\n No lockfile is created, since it gets recreated at need.\n &gt; **Note:** This call can trigger significant file size growth if run in\n parallel with write transactions, because it employs a read-only\n transaction. See long-lived transactions under caveats_sec.\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create(). It\n must have already been opened successfully.\n * `path` (direction in) - The directory in which the copy will reside. This\n directory must already exist and be writable but must otherwise be\n empty.\n # Returns\n\nA non-zero error value on failure and 0 on success."</span>]
<a href=#201 id=201 data-nosnippet>201</a>    </span><span class="kw">pub fn </span>mdb_env_copy(env: <span class="kw-2">*mut </span>MDB_env, path: <span class="kw-2">*const </span>::libc::c_char) -&gt; ::libc::c_int;
<a href=#202 id=202 data-nosnippet>202</a>}
<a href=#203 id=203 data-nosnippet>203</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#204 id=204 data-nosnippet>204</a>    <span class="attr">#[doc = <span class="string">"Copy an LMDB environment to the specified file descriptor.\n\n This function may be used to make a backup of an existing environment.\n No lockfile is created, since it gets recreated at need.\n &gt; **Note:** This call can trigger significant file size growth if run in\n parallel with write transactions, because it employs a read-only\n transaction. See long-lived transactions under caveats_sec.\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create(). It\n must have already been opened successfully.\n * `fd` (direction in) - The filedescriptor to write the copy to. It must\n have already been opened for Write access.\n # Returns\n\nA non-zero error value on failure and 0 on success."</span>]
<a href=#205 id=205 data-nosnippet>205</a>    </span><span class="kw">pub fn </span>mdb_env_copyfd(env: <span class="kw-2">*mut </span>MDB_env, fd: mdb_filehandle_t) -&gt; ::libc::c_int;
<a href=#206 id=206 data-nosnippet>206</a>}
<a href=#207 id=207 data-nosnippet>207</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#208 id=208 data-nosnippet>208</a>    <span class="attr">#[doc = <span class="string">"Copy an LMDB environment to the specified path, with options.\n\n This function may be used to make a backup of an existing environment.\n No lockfile is created, since it gets recreated at need.\n &gt; **Note:** This call can trigger significant file size growth if run in\n parallel with write transactions, because it employs a read-only\n transaction. See long-lived transactions under caveats_sec.\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create(). It\n must have already been opened successfully.\n * `path` (direction in) - The directory in which the copy will reside. This\n directory must already exist and be writable but must otherwise be\n empty.\n * `flags` (direction in) - Special options for this operation. This parameter\n must be set to 0 or by bitwise OR'ing together one or more of the\n values described here.\n &lt;ul&gt;\n\t&lt;li&gt;#MDB_CP_COMPACT - Perform compaction while copying: omit free\n\t\tpages and sequentially renumber all pages in output. This option\n\t\tconsumes more CPU and runs more slowly than the default.\n\t\tCurrently it fails if the environment has suffered a page leak.\n &lt;/ul&gt;\n # Returns\n\nA non-zero error value on failure and 0 on success."</span>]
<a href=#209 id=209 data-nosnippet>209</a>    </span><span class="kw">pub fn </span>mdb_env_copy2(
<a href=#210 id=210 data-nosnippet>210</a>        env: <span class="kw-2">*mut </span>MDB_env,
<a href=#211 id=211 data-nosnippet>211</a>        path: <span class="kw-2">*const </span>::libc::c_char,
<a href=#212 id=212 data-nosnippet>212</a>        flags: ::libc::c_uint,
<a href=#213 id=213 data-nosnippet>213</a>    ) -&gt; ::libc::c_int;
<a href=#214 id=214 data-nosnippet>214</a>}
<a href=#215 id=215 data-nosnippet>215</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#216 id=216 data-nosnippet>216</a>    <span class="attr">#[doc = <span class="string">"Copy an LMDB environment to the specified file descriptor,\n\twith options.\n\n This function may be used to make a backup of an existing environment.\n No lockfile is created, since it gets recreated at need. See\n #mdb_env_copy2() for further details.\n &gt; **Note:** This call can trigger significant file size growth if run in\n parallel with write transactions, because it employs a read-only\n transaction. See long-lived transactions under caveats_sec.\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create(). It\n must have already been opened successfully.\n * `fd` (direction in) - The filedescriptor to write the copy to. It must\n have already been opened for Write access.\n * `flags` (direction in) - Special options for this operation.\n See #mdb_env_copy2() for options.\n # Returns\n\nA non-zero error value on failure and 0 on success."</span>]
<a href=#217 id=217 data-nosnippet>217</a>    </span><span class="kw">pub fn </span>mdb_env_copyfd2(
<a href=#218 id=218 data-nosnippet>218</a>        env: <span class="kw-2">*mut </span>MDB_env,
<a href=#219 id=219 data-nosnippet>219</a>        fd: mdb_filehandle_t,
<a href=#220 id=220 data-nosnippet>220</a>        flags: ::libc::c_uint,
<a href=#221 id=221 data-nosnippet>221</a>    ) -&gt; ::libc::c_int;
<a href=#222 id=222 data-nosnippet>222</a>}
<a href=#223 id=223 data-nosnippet>223</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#224 id=224 data-nosnippet>224</a>    <span class="attr">#[doc = <span class="string">"Return statistics about the LMDB environment.\n\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create()\n * `stat` (direction out) - The address of an #MDB_stat structure\n \twhere the statistics will be copied"</span>]
<a href=#225 id=225 data-nosnippet>225</a>    </span><span class="kw">pub fn </span>mdb_env_stat(env: <span class="kw-2">*mut </span>MDB_env, stat: <span class="kw-2">*mut </span>MDB_stat) -&gt; ::libc::c_int;
<a href=#226 id=226 data-nosnippet>226</a>}
<a href=#227 id=227 data-nosnippet>227</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#228 id=228 data-nosnippet>228</a>    <span class="attr">#[doc = <span class="string">"Return information about the LMDB environment.\n\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create()\n * `stat` (direction out) - The address of an #MDB_envinfo structure\n \twhere the information will be copied"</span>]
<a href=#229 id=229 data-nosnippet>229</a>    </span><span class="kw">pub fn </span>mdb_env_info(env: <span class="kw-2">*mut </span>MDB_env, stat: <span class="kw-2">*mut </span>MDB_envinfo) -&gt; ::libc::c_int;
<a href=#230 id=230 data-nosnippet>230</a>}
<a href=#231 id=231 data-nosnippet>231</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#232 id=232 data-nosnippet>232</a>    <span class="attr">#[doc = <span class="string">"Flush the data buffers to disk.\n\n Data is always written to disk when #mdb_txn_commit() is called,\n but the operating system may keep it buffered. LMDB always flushes\n the OS buffers upon commit as well, unless the environment was\n opened with #MDB_NOSYNC or in part #MDB_NOMETASYNC. This call is\n not valid if the environment was opened with #MDB_RDONLY.\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create()\n * `force` (direction in) - If non-zero, force a synchronous flush. Otherwise\n if the environment has the #MDB_NOSYNC flag set the flushes\n\twill be omitted, and with #MDB_MAPASYNC they will be asynchronous.\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;EACCES - the environment is read-only.\n\t&lt;li&gt;EINVAL - an invalid parameter was specified.\n\t&lt;li&gt;EIO - an error occurred during synchronization.\n &lt;/ul&gt;"</span>]
<a href=#233 id=233 data-nosnippet>233</a>    </span><span class="kw">pub fn </span>mdb_env_sync(env: <span class="kw-2">*mut </span>MDB_env, force: ::libc::c_int) -&gt; ::libc::c_int;
<a href=#234 id=234 data-nosnippet>234</a>}
<a href=#235 id=235 data-nosnippet>235</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#236 id=236 data-nosnippet>236</a>    <span class="attr">#[doc = <span class="string">"Close the environment and release the memory map.\n\n Only a single thread may call this function. All transactions, databases,\n and cursors must already be closed before calling this function. Attempts to\n use any such handles after calling this function will cause a SIGSEGV.\n The environment handle will be freed and must not be used again after this call.\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create()"</span>]
<a href=#237 id=237 data-nosnippet>237</a>    </span><span class="kw">pub fn </span>mdb_env_close(env: <span class="kw-2">*mut </span>MDB_env);
<a href=#238 id=238 data-nosnippet>238</a>}
<a href=#239 id=239 data-nosnippet>239</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#240 id=240 data-nosnippet>240</a>    <span class="attr">#[doc = <span class="string">"Set environment flags.\n\n This may be used to set some flags in addition to those from\n #mdb_env_open(), or to unset these flags. If several threads\n change the flags at the same time, the result is undefined.\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create()\n * `flags` (direction in) - The flags to change, bitwise OR'ed together\n * `onoff` (direction in) - A non-zero value sets the flags, zero clears them.\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;EINVAL - an invalid parameter was specified.\n &lt;/ul&gt;"</span>]
<a href=#241 id=241 data-nosnippet>241</a>    </span><span class="kw">pub fn </span>mdb_env_set_flags(
<a href=#242 id=242 data-nosnippet>242</a>        env: <span class="kw-2">*mut </span>MDB_env,
<a href=#243 id=243 data-nosnippet>243</a>        flags: ::libc::c_uint,
<a href=#244 id=244 data-nosnippet>244</a>        onoff: ::libc::c_int,
<a href=#245 id=245 data-nosnippet>245</a>    ) -&gt; ::libc::c_int;
<a href=#246 id=246 data-nosnippet>246</a>}
<a href=#247 id=247 data-nosnippet>247</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#248 id=248 data-nosnippet>248</a>    <span class="attr">#[doc = <span class="string">"Get environment flags.\n\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create()\n * `flags` (direction out) - The address of an integer to store the flags\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;EINVAL - an invalid parameter was specified.\n &lt;/ul&gt;"</span>]
<a href=#249 id=249 data-nosnippet>249</a>    </span><span class="kw">pub fn </span>mdb_env_get_flags(env: <span class="kw-2">*mut </span>MDB_env, flags: <span class="kw-2">*mut </span>::libc::c_uint) -&gt; ::libc::c_int;
<a href=#250 id=250 data-nosnippet>250</a>}
<a href=#251 id=251 data-nosnippet>251</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#252 id=252 data-nosnippet>252</a>    <span class="attr">#[doc = <span class="string">"Return the path that was used in #mdb_env_open().\n\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create()\n * `path` (direction out) - Address of a string pointer to contain the path. This\n is the actual string in the environment, not a copy. It should not be\n altered in any way.\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;EINVAL - an invalid parameter was specified.\n &lt;/ul&gt;"</span>]
<a href=#253 id=253 data-nosnippet>253</a>    </span><span class="kw">pub fn </span>mdb_env_get_path(env: <span class="kw-2">*mut </span>MDB_env, path: <span class="kw-2">*mut *const </span>::libc::c_char) -&gt; ::libc::c_int;
<a href=#254 id=254 data-nosnippet>254</a>}
<a href=#255 id=255 data-nosnippet>255</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#256 id=256 data-nosnippet>256</a>    <span class="attr">#[doc = <span class="string">"Return the filedescriptor for the given environment.\n\n This function may be called after fork(), so the descriptor can be\n closed before exec*(). Other LMDB file descriptors have FD_CLOEXEC.\n (Until LMDB 0.9.18, only the lockfile had that.)\n\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create()\n * `fd` (direction out) - Address of a mdb_filehandle_t to contain the descriptor.\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;EINVAL - an invalid parameter was specified.\n &lt;/ul&gt;"</span>]
<a href=#257 id=257 data-nosnippet>257</a>    </span><span class="kw">pub fn </span>mdb_env_get_fd(env: <span class="kw-2">*mut </span>MDB_env, fd: <span class="kw-2">*mut </span>mdb_filehandle_t) -&gt; ::libc::c_int;
<a href=#258 id=258 data-nosnippet>258</a>}
<a href=#259 id=259 data-nosnippet>259</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#260 id=260 data-nosnippet>260</a>    <span class="attr">#[doc = <span class="string">"Set the size of the memory map to use for this environment.\n\n The size should be a multiple of the OS page size. The default is\n 10485760 bytes. The size of the memory map is also the maximum size\n of the database. The value should be chosen as large as possible,\n to accommodate future growth of the database.\n This function should be called after #mdb_env_create() and before #mdb_env_open().\n It may be called at later times if no transactions are active in\n this process. Note that the library does not check for this condition,\n the caller must ensure it explicitly.\n\n The new size takes effect immediately for the current process but\n will not be persisted to any others until a write transaction has been\n committed by the current process. Also, only mapsize increases are\n persisted into the environment.\n\n If the mapsize is increased by another process, and data has grown\n beyond the range of the current mapsize, #mdb_txn_begin() will\n return #MDB_MAP_RESIZED. This function may be called with a size\n of zero to adopt the new size.\n\n Any attempt to set a size smaller than the space already consumed\n by the environment will be silently changed to the current size of the used space.\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create()\n * `size` (direction in) - The size in bytes\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;EINVAL - an invalid parameter was specified, or the environment has\n \tan active write transaction.\n &lt;/ul&gt;"</span>]
<a href=#261 id=261 data-nosnippet>261</a>    </span><span class="kw">pub fn </span>mdb_env_set_mapsize(env: <span class="kw-2">*mut </span>MDB_env, size: mdb_size_t) -&gt; ::libc::c_int;
<a href=#262 id=262 data-nosnippet>262</a>}
<a href=#263 id=263 data-nosnippet>263</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#264 id=264 data-nosnippet>264</a>    <span class="attr">#[doc = <span class="string">"Set the maximum number of threads/reader slots for the environment.\n\n This defines the number of slots in the lock table that is used to track readers in the\n the environment. The default is 126.\n Starting a read-only transaction normally ties a lock table slot to the\n current thread until the environment closes or the thread exits. If\n MDB_NOTLS is in use, #mdb_txn_begin() instead ties the slot to the\n MDB_txn object until it or the #MDB_env object is destroyed.\n This function may only be called after #mdb_env_create() and before #mdb_env_open().\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create()\n * `readers` (direction in) - The maximum number of reader lock table slots\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;EINVAL - an invalid parameter was specified, or the environment is already open.\n &lt;/ul&gt;"</span>]
<a href=#265 id=265 data-nosnippet>265</a>    </span><span class="kw">pub fn </span>mdb_env_set_maxreaders(env: <span class="kw-2">*mut </span>MDB_env, readers: ::libc::c_uint) -&gt; ::libc::c_int;
<a href=#266 id=266 data-nosnippet>266</a>}
<a href=#267 id=267 data-nosnippet>267</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#268 id=268 data-nosnippet>268</a>    <span class="attr">#[doc = <span class="string">"Get the maximum number of threads/reader slots for the environment.\n\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create()\n * `readers` (direction out) - Address of an integer to store the number of readers\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;EINVAL - an invalid parameter was specified.\n &lt;/ul&gt;"</span>]
<a href=#269 id=269 data-nosnippet>269</a>    </span><span class="kw">pub fn </span>mdb_env_get_maxreaders(env: <span class="kw-2">*mut </span>MDB_env, readers: <span class="kw-2">*mut </span>::libc::c_uint)
<a href=#270 id=270 data-nosnippet>270</a>        -&gt; ::libc::c_int;
<a href=#271 id=271 data-nosnippet>271</a>}
<a href=#272 id=272 data-nosnippet>272</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#273 id=273 data-nosnippet>273</a>    <span class="attr">#[doc = <span class="string">"Set the maximum number of named databases for the environment.\n\n This function is only needed if multiple databases will be used in the\n environment. Simpler applications that use the environment as a single\n unnamed database can ignore this option.\n This function may only be called after #mdb_env_create() and before #mdb_env_open().\n\n Currently a moderate number of slots are cheap but a huge number gets\n expensive: 7-120 words per transaction, and every #mdb_dbi_open()\n does a linear search of the opened slots.\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create()\n * `dbs` (direction in) - The maximum number of databases\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;EINVAL - an invalid parameter was specified, or the environment is already open.\n &lt;/ul&gt;"</span>]
<a href=#274 id=274 data-nosnippet>274</a>    </span><span class="kw">pub fn </span>mdb_env_set_maxdbs(env: <span class="kw-2">*mut </span>MDB_env, dbs: MDB_dbi) -&gt; ::libc::c_int;
<a href=#275 id=275 data-nosnippet>275</a>}
<a href=#276 id=276 data-nosnippet>276</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#277 id=277 data-nosnippet>277</a>    <span class="attr">#[doc = <span class="string">"Get the maximum size of keys and #MDB_DUPSORT data we can write.\n\n Depends on the compile-time constant #MDB_MAXKEYSIZE. Default 511.\n See MDB_val.\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create()\n # Returns\n\nThe maximum size of a key we can write"</span>]
<a href=#278 id=278 data-nosnippet>278</a>    </span><span class="kw">pub fn </span>mdb_env_get_maxkeysize(env: <span class="kw-2">*mut </span>MDB_env) -&gt; ::libc::c_int;
<a href=#279 id=279 data-nosnippet>279</a>}
<a href=#280 id=280 data-nosnippet>280</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#281 id=281 data-nosnippet>281</a>    <span class="attr">#[doc = <span class="string">"Set application information associated with the #MDB_env.\n\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create()\n * `ctx` (direction in) - An arbitrary pointer for whatever the application needs.\n # Returns\n\nA non-zero error value on failure and 0 on success."</span>]
<a href=#282 id=282 data-nosnippet>282</a>    </span><span class="kw">pub fn </span>mdb_env_set_userctx(env: <span class="kw-2">*mut </span>MDB_env, ctx: <span class="kw-2">*mut </span>::libc::c_void) -&gt; ::libc::c_int;
<a href=#283 id=283 data-nosnippet>283</a>}
<a href=#284 id=284 data-nosnippet>284</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#285 id=285 data-nosnippet>285</a>    <span class="attr">#[doc = <span class="string">"Get the application information associated with the #MDB_env.\n\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create()\n # Returns\n\nThe pointer set by #mdb_env_set_userctx()."</span>]
<a href=#286 id=286 data-nosnippet>286</a>    </span><span class="kw">pub fn </span>mdb_env_get_userctx(env: <span class="kw-2">*mut </span>MDB_env) -&gt; <span class="kw-2">*mut </span>::libc::c_void;
<a href=#287 id=287 data-nosnippet>287</a>}
<a href=#288 id=288 data-nosnippet>288</a><span class="attr">#[doc = <span class="string">"A callback function for most LMDB assert() failures,\n called before printing the message and aborting.\n\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create().\n * `msg` (direction in) - The assertion message, not including newline."</span>]
<a href=#289 id=289 data-nosnippet>289</a></span><span class="kw">pub type </span>MDB_assert_func =
<a href=#290 id=290 data-nosnippet>290</a>    ::std::option::Option&lt;<span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(env: <span class="kw-2">*mut </span>MDB_env, msg: <span class="kw-2">*const </span>::libc::c_char)&gt;;
<a href=#291 id=291 data-nosnippet>291</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#292 id=292 data-nosnippet>292</a>    <span class="attr">#[doc = <span class="string">"Set or reset the assert() callback of the environment.\n Disabled if liblmdb is built with NDEBUG.\n &gt; **Note:** This hack should become obsolete as lmdb's error handling matures.\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create().\n * `func` (direction in) - An #MDB_assert_func function, or 0.\n # Returns\n\nA non-zero error value on failure and 0 on success."</span>]
<a href=#293 id=293 data-nosnippet>293</a>    </span><span class="kw">pub fn </span>mdb_env_set_assert(env: <span class="kw-2">*mut </span>MDB_env, func: MDB_assert_func) -&gt; ::libc::c_int;
<a href=#294 id=294 data-nosnippet>294</a>}
<a href=#295 id=295 data-nosnippet>295</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#296 id=296 data-nosnippet>296</a>    <span class="attr">#[doc = <span class="string">"Create a transaction for use with the environment.\n\n The transaction handle may be discarded using #mdb_txn_abort() or #mdb_txn_commit().\n &gt; **Note:** A transaction and its cursors must only be used by a single\n thread, and a thread may only have a single transaction at a time.\n If #MDB_NOTLS is in use, this does not apply to read-only transactions.\n &gt; **Note:** Cursors may not span transactions.\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create()\n * `parent` (direction in) - If this parameter is non-NULL, the new transaction\n will be a nested transaction, with the transaction indicated by **parent**\n as its parent. Transactions may be nested to any level. A parent\n transaction and its cursors may not issue any other operations than\n mdb_txn_commit and mdb_txn_abort while it has active child transactions.\n * `flags` (direction in) - Special options for this transaction. This parameter\n must be set to 0 or by bitwise OR'ing together one or more of the\n values described here.\n &lt;ul&gt;\n\t&lt;li&gt;#MDB_RDONLY\n\t\tThis transaction will not perform any write operations.\n\t&lt;li&gt;#MDB_NOSYNC\n\t\tDon't flush system buffers to disk when committing this transaction.\n\t&lt;li&gt;#MDB_NOMETASYNC\n\t\tFlush system buffers but omit metadata flush when committing this transaction.\n &lt;/ul&gt;\n * `txn` (direction out) - Address where the new #MDB_txn handle will be stored\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;#MDB_PANIC - a fatal error occurred earlier and the environment\n\t\tmust be shut down.\n\t&lt;li&gt;#MDB_MAP_RESIZED - another process wrote data beyond this MDB_env's\n\t\tmapsize and this environment's map must be resized as well.\n\t\tSee #mdb_env_set_mapsize().\n\t&lt;li&gt;#MDB_READERS_FULL - a read-only transaction was requested and\n\t\tthe reader lock table is full. See #mdb_env_set_maxreaders().\n\t&lt;li&gt;ENOMEM - out of memory.\n &lt;/ul&gt;"</span>]
<a href=#297 id=297 data-nosnippet>297</a>    </span><span class="kw">pub fn </span>mdb_txn_begin(
<a href=#298 id=298 data-nosnippet>298</a>        env: <span class="kw-2">*mut </span>MDB_env,
<a href=#299 id=299 data-nosnippet>299</a>        parent: <span class="kw-2">*mut </span>MDB_txn,
<a href=#300 id=300 data-nosnippet>300</a>        flags: ::libc::c_uint,
<a href=#301 id=301 data-nosnippet>301</a>        txn: <span class="kw-2">*mut *mut </span>MDB_txn,
<a href=#302 id=302 data-nosnippet>302</a>    ) -&gt; ::libc::c_int;
<a href=#303 id=303 data-nosnippet>303</a>}
<a href=#304 id=304 data-nosnippet>304</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#305 id=305 data-nosnippet>305</a>    <span class="attr">#[doc = <span class="string">"Returns the transaction's #MDB_env\n\n # Arguments\n\n* `txn` (direction in) - A transaction handle returned by #mdb_txn_begin()"</span>]
<a href=#306 id=306 data-nosnippet>306</a>    </span><span class="kw">pub fn </span>mdb_txn_env(txn: <span class="kw-2">*mut </span>MDB_txn) -&gt; <span class="kw-2">*mut </span>MDB_env;
<a href=#307 id=307 data-nosnippet>307</a>}
<a href=#308 id=308 data-nosnippet>308</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#309 id=309 data-nosnippet>309</a>    <span class="attr">#[doc = <span class="string">"Return the transaction's ID.\n\n This returns the identifier associated with this transaction. For a\n read-only transaction, this corresponds to the snapshot being read;\n concurrent readers will frequently have the same transaction ID.\n\n # Arguments\n\n* `txn` (direction in) - A transaction handle returned by #mdb_txn_begin()\n # Returns\n\nA transaction ID, valid if input is an active transaction."</span>]
<a href=#310 id=310 data-nosnippet>310</a>    </span><span class="kw">pub fn </span>mdb_txn_id(txn: <span class="kw-2">*mut </span>MDB_txn) -&gt; mdb_size_t;
<a href=#311 id=311 data-nosnippet>311</a>}
<a href=#312 id=312 data-nosnippet>312</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#313 id=313 data-nosnippet>313</a>    <span class="attr">#[doc = <span class="string">"Commit all the operations of a transaction into the database.\n\n The transaction handle is freed. It and its cursors must not be used\n again after this call, except with #mdb_cursor_renew().\n &gt; **Note:** Earlier documentation incorrectly said all cursors would be freed.\n Only write-transactions free cursors.\n # Arguments\n\n* `txn` (direction in) - A transaction handle returned by #mdb_txn_begin()\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;EINVAL - an invalid parameter was specified.\n\t&lt;li&gt;ENOSPC - no more disk space.\n\t&lt;li&gt;EIO - a low-level I/O error occurred while writing.\n\t&lt;li&gt;ENOMEM - out of memory.\n &lt;/ul&gt;"</span>]
<a href=#314 id=314 data-nosnippet>314</a>    </span><span class="kw">pub fn </span>mdb_txn_commit(txn: <span class="kw-2">*mut </span>MDB_txn) -&gt; ::libc::c_int;
<a href=#315 id=315 data-nosnippet>315</a>}
<a href=#316 id=316 data-nosnippet>316</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#317 id=317 data-nosnippet>317</a>    <span class="attr">#[doc = <span class="string">"Abandon all the operations of the transaction instead of saving them.\n\n The transaction handle is freed. It and its cursors must not be used\n again after this call, except with #mdb_cursor_renew().\n &gt; **Note:** Earlier documentation incorrectly said all cursors would be freed.\n Only write-transactions free cursors.\n # Arguments\n\n* `txn` (direction in) - A transaction handle returned by #mdb_txn_begin()"</span>]
<a href=#318 id=318 data-nosnippet>318</a>    </span><span class="kw">pub fn </span>mdb_txn_abort(txn: <span class="kw-2">*mut </span>MDB_txn);
<a href=#319 id=319 data-nosnippet>319</a>}
<a href=#320 id=320 data-nosnippet>320</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#321 id=321 data-nosnippet>321</a>    <span class="attr">#[doc = <span class="string">"Reset a read-only transaction.\n\n Abort the transaction like #mdb_txn_abort(), but keep the transaction\n handle. #mdb_txn_renew() may reuse the handle. This saves allocation\n overhead if the process will start a new read-only transaction soon,\n and also locking overhead if #MDB_NOTLS is in use. The reader table\n lock is released, but the table slot stays tied to its thread or\n #MDB_txn. Use mdb_txn_abort() to discard a reset handle, and to free\n its lock table slot if MDB_NOTLS is in use.\n Cursors opened within the transaction must not be used\n again after this call, except with #mdb_cursor_renew().\n Reader locks generally don't interfere with writers, but they keep old\n versions of database pages allocated. Thus they prevent the old pages\n from being reused when writers commit new data, and so under heavy load\n the database size may grow much more rapidly than otherwise.\n # Arguments\n\n* `txn` (direction in) - A transaction handle returned by #mdb_txn_begin()"</span>]
<a href=#322 id=322 data-nosnippet>322</a>    </span><span class="kw">pub fn </span>mdb_txn_reset(txn: <span class="kw-2">*mut </span>MDB_txn);
<a href=#323 id=323 data-nosnippet>323</a>}
<a href=#324 id=324 data-nosnippet>324</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#325 id=325 data-nosnippet>325</a>    <span class="attr">#[doc = <span class="string">"Renew a read-only transaction.\n\n This acquires a new reader lock for a transaction handle that had been\n released by #mdb_txn_reset(). It must be called before a reset transaction\n may be used again.\n # Arguments\n\n* `txn` (direction in) - A transaction handle returned by #mdb_txn_begin()\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;#MDB_PANIC - a fatal error occurred earlier and the environment\n\t\tmust be shut down.\n\t&lt;li&gt;EINVAL - an invalid parameter was specified.\n &lt;/ul&gt;"</span>]
<a href=#326 id=326 data-nosnippet>326</a>    </span><span class="kw">pub fn </span>mdb_txn_renew(txn: <span class="kw-2">*mut </span>MDB_txn) -&gt; ::libc::c_int;
<a href=#327 id=327 data-nosnippet>327</a>}
<a href=#328 id=328 data-nosnippet>328</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#329 id=329 data-nosnippet>329</a>    <span class="attr">#[doc = <span class="string">"Open a database in the environment.\n\n A database handle denotes the name and parameters of a database,\n independently of whether such a database exists.\n The database handle may be discarded by calling #mdb_dbi_close().\n The old database handle is returned if the database was already open.\n The handle may only be closed once.\n\n The database handle will be private to the current transaction until\n the transaction is successfully committed. If the transaction is\n aborted the handle will be closed automatically.\n After a successful commit the handle will reside in the shared\n environment, and may be used by other transactions.\n\n This function must not be called from multiple concurrent\n transactions in the same process. A transaction that uses\n this function must finish (either commit or abort) before\n any other transaction in the process may use this function.\n\n To use named databases (with name != NULL), #mdb_env_set_maxdbs()\n must be called before opening the environment. Database names are\n keys in the unnamed database, and may be read but not written.\n\n # Arguments\n\n* `txn` (direction in) - A transaction handle returned by #mdb_txn_begin()\n * `name` (direction in) - The name of the database to open. If only a single\n \tdatabase is needed in the environment, this value may be NULL.\n * `flags` (direction in) - Special options for this database. This parameter\n must be set to 0 or by bitwise OR'ing together one or more of the\n values described here.\n &lt;ul&gt;\n\t&lt;li&gt;#MDB_REVERSEKEY\n\t\tKeys are strings to be compared in reverse order, from the end\n\t\tof the strings to the beginning. By default, Keys are treated as strings and\n\t\tcompared from beginning to end.\n\t&lt;li&gt;#MDB_DUPSORT\n\t\tDuplicate keys may be used in the database. (Or, from another perspective,\n\t\tkeys may have multiple data items, stored in sorted order.) By default\n\t\tkeys must be unique and may have only a single data item.\n\t&lt;li&gt;#MDB_INTEGERKEY\n\t\tKeys are binary integers in native byte order, either unsigned int\n\t\tor #mdb_size_t, and will be sorted as such.\n\t\t(lmdb expects 32-bit int &lt;= size_t &lt;= 32/64-bit mdb_size_t.)\n\t\tThe keys must all be of the same size.\n\t&lt;li&gt;#MDB_DUPFIXED\n\t\tThis flag may only be used in combination with #MDB_DUPSORT. This option\n\t\ttells the library that the data items for this database are all the same\n\t\tsize, which allows further optimizations in storage and retrieval. When\n\t\tall data items are the same size, the #MDB_GET_MULTIPLE, #MDB_NEXT_MULTIPLE\n\t\tand #MDB_PREV_MULTIPLE cursor operations may be used to retrieve multiple\n\t\titems at once.\n\t&lt;li&gt;#MDB_INTEGERDUP\n\t\tThis option specifies that duplicate data items are binary integers,\n\t\tsimilar to #MDB_INTEGERKEY keys.\n\t&lt;li&gt;#MDB_REVERSEDUP\n\t\tThis option specifies that duplicate data items should be compared as\n\t\tstrings in reverse order.\n\t&lt;li&gt;#MDB_CREATE\n\t\tCreate the named database if it doesn't exist. This option is not\n\t\tallowed in a read-only transaction or a read-only environment.\n &lt;/ul&gt;\n * `dbi` (direction out) - Address where the new #MDB_dbi handle will be stored\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;#MDB_NOTFOUND - the specified database doesn't exist in the environment\n\t\tand #MDB_CREATE was not specified.\n\t&lt;li&gt;#MDB_DBS_FULL - too many databases have been opened. See #mdb_env_set_maxdbs().\n &lt;/ul&gt;"</span>]
<a href=#330 id=330 data-nosnippet>330</a>    </span><span class="kw">pub fn </span>mdb_dbi_open(
<a href=#331 id=331 data-nosnippet>331</a>        txn: <span class="kw-2">*mut </span>MDB_txn,
<a href=#332 id=332 data-nosnippet>332</a>        name: <span class="kw-2">*const </span>::libc::c_char,
<a href=#333 id=333 data-nosnippet>333</a>        flags: ::libc::c_uint,
<a href=#334 id=334 data-nosnippet>334</a>        dbi: <span class="kw-2">*mut </span>MDB_dbi,
<a href=#335 id=335 data-nosnippet>335</a>    ) -&gt; ::libc::c_int;
<a href=#336 id=336 data-nosnippet>336</a>}
<a href=#337 id=337 data-nosnippet>337</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#338 id=338 data-nosnippet>338</a>    <span class="attr">#[doc = <span class="string">"Retrieve statistics for a database.\n\n # Arguments\n\n* `txn` (direction in) - A transaction handle returned by #mdb_txn_begin()\n * `dbi` (direction in) - A database handle returned by #mdb_dbi_open()\n * `stat` (direction out) - The address of an #MDB_stat structure\n \twhere the statistics will be copied\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;EINVAL - an invalid parameter was specified.\n &lt;/ul&gt;"</span>]
<a href=#339 id=339 data-nosnippet>339</a>    </span><span class="kw">pub fn </span>mdb_stat(txn: <span class="kw-2">*mut </span>MDB_txn, dbi: MDB_dbi, stat: <span class="kw-2">*mut </span>MDB_stat) -&gt; ::libc::c_int;
<a href=#340 id=340 data-nosnippet>340</a>}
<a href=#341 id=341 data-nosnippet>341</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#342 id=342 data-nosnippet>342</a>    <span class="attr">#[doc = <span class="string">"Retrieve the DB flags for a database handle.\n\n # Arguments\n\n* `txn` (direction in) - A transaction handle returned by #mdb_txn_begin()\n * `dbi` (direction in) - A database handle returned by #mdb_dbi_open()\n * `flags` (direction out) - Address where the flags will be returned.\n # Returns\n\nA non-zero error value on failure and 0 on success."</span>]
<a href=#343 id=343 data-nosnippet>343</a>    </span><span class="kw">pub fn </span>mdb_dbi_flags(
<a href=#344 id=344 data-nosnippet>344</a>        txn: <span class="kw-2">*mut </span>MDB_txn,
<a href=#345 id=345 data-nosnippet>345</a>        dbi: MDB_dbi,
<a href=#346 id=346 data-nosnippet>346</a>        flags: <span class="kw-2">*mut </span>::libc::c_uint,
<a href=#347 id=347 data-nosnippet>347</a>    ) -&gt; ::libc::c_int;
<a href=#348 id=348 data-nosnippet>348</a>}
<a href=#349 id=349 data-nosnippet>349</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#350 id=350 data-nosnippet>350</a>    <span class="attr">#[doc = <span class="string">"Close a database handle. Normally unnecessary. Use with care:\n\n This call is not mutex protected. Handles should only be closed by\n a single thread, and only if no other threads are going to reference\n the database handle or one of its cursors any further. Do not close\n a handle if an existing transaction has modified its database.\n Doing so can cause misbehavior from database corruption to errors\n like MDB_BAD_VALSIZE (since the DB name is gone).\n\n Closing a database handle is not necessary, but lets #mdb_dbi_open()\n reuse the handle value. Usually it's better to set a bigger\n #mdb_env_set_maxdbs(), unless that value would be large.\n\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create()\n * `dbi` (direction in) - A database handle returned by #mdb_dbi_open()"</span>]
<a href=#351 id=351 data-nosnippet>351</a>    </span><span class="kw">pub fn </span>mdb_dbi_close(env: <span class="kw-2">*mut </span>MDB_env, dbi: MDB_dbi);
<a href=#352 id=352 data-nosnippet>352</a>}
<a href=#353 id=353 data-nosnippet>353</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#354 id=354 data-nosnippet>354</a>    <span class="attr">#[doc = <span class="string">"Empty or delete+close a database.\n\n See #mdb_dbi_close() for restrictions about closing the DB handle.\n # Arguments\n\n* `txn` (direction in) - A transaction handle returned by #mdb_txn_begin()\n * `dbi` (direction in) - A database handle returned by #mdb_dbi_open()\n * `del` (direction in) - 0 to empty the DB, 1 to delete it from the\n environment and close the DB handle.\n # Returns\n\nA non-zero error value on failure and 0 on success."</span>]
<a href=#355 id=355 data-nosnippet>355</a>    </span><span class="kw">pub fn </span>mdb_drop(txn: <span class="kw-2">*mut </span>MDB_txn, dbi: MDB_dbi, del: ::libc::c_int) -&gt; ::libc::c_int;
<a href=#356 id=356 data-nosnippet>356</a>}
<a href=#357 id=357 data-nosnippet>357</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#358 id=358 data-nosnippet>358</a>    <span class="attr">#[doc = <span class="string">"Set a custom key comparison function for a database.\n\n The comparison function is called whenever it is necessary to compare a\n key specified by the application with a key currently stored in the database.\n If no comparison function is specified, and no special key flags were specified\n with #mdb_dbi_open(), the keys are compared lexically, with shorter keys collating\n before longer keys.\n This function must be called before any data access functions are used,\n otherwise data corruption may occur. The same comparison function must be used by every\n program accessing the database, every time the database is used.\n # Arguments\n\n* `txn` (direction in) - A transaction handle returned by #mdb_txn_begin()\n * `dbi` (direction in) - A database handle returned by #mdb_dbi_open()\n * `cmp` (direction in) - A #MDB_cmp_func function\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;EINVAL - an invalid parameter was specified.\n &lt;/ul&gt;"</span>]
<a href=#359 id=359 data-nosnippet>359</a>    </span><span class="kw">pub fn </span>mdb_set_compare(txn: <span class="kw-2">*mut </span>MDB_txn, dbi: MDB_dbi, cmp: MDB_cmp_func) -&gt; ::libc::c_int;
<a href=#360 id=360 data-nosnippet>360</a>}
<a href=#361 id=361 data-nosnippet>361</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#362 id=362 data-nosnippet>362</a>    <span class="attr">#[doc = <span class="string">"Set a custom data comparison function for a #MDB_DUPSORT database.\n\n This comparison function is called whenever it is necessary to compare a data\n item specified by the application with a data item currently stored in the database.\n This function only takes effect if the database was opened with the #MDB_DUPSORT\n flag.\n If no comparison function is specified, and no special key flags were specified\n with #mdb_dbi_open(), the data items are compared lexically, with shorter items collating\n before longer items.\n This function must be called before any data access functions are used,\n otherwise data corruption may occur. The same comparison function must be used by every\n program accessing the database, every time the database is used.\n # Arguments\n\n* `txn` (direction in) - A transaction handle returned by #mdb_txn_begin()\n * `dbi` (direction in) - A database handle returned by #mdb_dbi_open()\n * `cmp` (direction in) - A #MDB_cmp_func function\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;EINVAL - an invalid parameter was specified.\n &lt;/ul&gt;"</span>]
<a href=#363 id=363 data-nosnippet>363</a>    </span><span class="kw">pub fn </span>mdb_set_dupsort(txn: <span class="kw-2">*mut </span>MDB_txn, dbi: MDB_dbi, cmp: MDB_cmp_func) -&gt; ::libc::c_int;
<a href=#364 id=364 data-nosnippet>364</a>}
<a href=#365 id=365 data-nosnippet>365</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#366 id=366 data-nosnippet>366</a>    <span class="attr">#[doc = <span class="string">"Set a relocation function for a #MDB_FIXEDMAP database.\n\n The relocation function is called whenever it is necessary to move the data\n of an item to a different position in the database (e.g. through tree\n balancing operations, shifts as a result of adds or deletes, etc.). It is\n intended to allow address/position-dependent data items to be stored in\n a database in an environment opened with the #MDB_FIXEDMAP option.\n Currently the relocation feature is unimplemented and setting\n this function has no effect.\n # Arguments\n\n* `txn` (direction in) - A transaction handle returned by #mdb_txn_begin()\n * `dbi` (direction in) - A database handle returned by #mdb_dbi_open()\n * `rel` (direction in) - A #MDB_rel_func function\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;EINVAL - an invalid parameter was specified.\n &lt;/ul&gt;"</span>]
<a href=#367 id=367 data-nosnippet>367</a>    </span><span class="kw">pub fn </span>mdb_set_relfunc(txn: <span class="kw-2">*mut </span>MDB_txn, dbi: MDB_dbi, rel: MDB_rel_func) -&gt; ::libc::c_int;
<a href=#368 id=368 data-nosnippet>368</a>}
<a href=#369 id=369 data-nosnippet>369</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#370 id=370 data-nosnippet>370</a>    <span class="attr">#[doc = <span class="string">"Set a context pointer for a #MDB_FIXEDMAP database's relocation function.\n\n See #mdb_set_relfunc and #MDB_rel_func for more details.\n # Arguments\n\n* `txn` (direction in) - A transaction handle returned by #mdb_txn_begin()\n * `dbi` (direction in) - A database handle returned by #mdb_dbi_open()\n * `ctx` (direction in) - An arbitrary pointer for whatever the application needs.\n It will be passed to the callback function set by #mdb_set_relfunc\n as its **relctx** parameter whenever the callback is invoked.\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;EINVAL - an invalid parameter was specified.\n &lt;/ul&gt;"</span>]
<a href=#371 id=371 data-nosnippet>371</a>    </span><span class="kw">pub fn </span>mdb_set_relctx(
<a href=#372 id=372 data-nosnippet>372</a>        txn: <span class="kw-2">*mut </span>MDB_txn,
<a href=#373 id=373 data-nosnippet>373</a>        dbi: MDB_dbi,
<a href=#374 id=374 data-nosnippet>374</a>        ctx: <span class="kw-2">*mut </span>::libc::c_void,
<a href=#375 id=375 data-nosnippet>375</a>    ) -&gt; ::libc::c_int;
<a href=#376 id=376 data-nosnippet>376</a>}
<a href=#377 id=377 data-nosnippet>377</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#378 id=378 data-nosnippet>378</a>    <span class="attr">#[doc = <span class="string">"Get items from a database.\n\n This function retrieves key/data pairs from the database. The address\n and length of the data associated with the specified **key** are returned\n in the structure to which **data** refers.\n If the database supports duplicate keys (#MDB_DUPSORT) then the\n first data item for the key will be returned. Retrieval of other\n items requires the use of #mdb_cursor_get().\n\n &gt; **Note:** The memory pointed to by the returned values is owned by the\n database. The caller need not dispose of the memory, and may not\n modify it in any way. For values returned in a read-only transaction\n any modification attempts will cause a SIGSEGV.\n &gt; **Note:** Values returned from the database are valid only until a\n subsequent update operation, or the end of the transaction.\n # Arguments\n\n* `txn` (direction in) - A transaction handle returned by #mdb_txn_begin()\n * `dbi` (direction in) - A database handle returned by #mdb_dbi_open()\n * `key` (direction in) - The key to search for in the database\n * `data` (direction out) - The data corresponding to the key\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;#MDB_NOTFOUND - the key was not in the database.\n\t&lt;li&gt;EINVAL - an invalid parameter was specified.\n &lt;/ul&gt;"</span>]
<a href=#379 id=379 data-nosnippet>379</a>    </span><span class="kw">pub fn </span>mdb_get(
<a href=#380 id=380 data-nosnippet>380</a>        txn: <span class="kw-2">*mut </span>MDB_txn,
<a href=#381 id=381 data-nosnippet>381</a>        dbi: MDB_dbi,
<a href=#382 id=382 data-nosnippet>382</a>        key: <span class="kw-2">*mut </span>MDB_val,
<a href=#383 id=383 data-nosnippet>383</a>        data: <span class="kw-2">*mut </span>MDB_val,
<a href=#384 id=384 data-nosnippet>384</a>    ) -&gt; ::libc::c_int;
<a href=#385 id=385 data-nosnippet>385</a>}
<a href=#386 id=386 data-nosnippet>386</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#387 id=387 data-nosnippet>387</a>    <span class="attr">#[doc = <span class="string">"Store items into a database.\n\n This function stores key/data pairs in the database. The default behavior\n is to enter the new key/data pair, replacing any previously existing key\n if duplicates are disallowed, or adding a duplicate data item if\n duplicates are allowed (#MDB_DUPSORT).\n # Arguments\n\n* `txn` (direction in) - A transaction handle returned by #mdb_txn_begin()\n * `dbi` (direction in) - A database handle returned by #mdb_dbi_open()\n * `key` (direction in) - The key to store in the database\n * `data` (direction in, out) - The data to store\n * `flags` (direction in) - Special options for this operation. This parameter\n must be set to 0 or by bitwise OR'ing together one or more of the\n values described here.\n &lt;ul&gt;\n\t&lt;li&gt;#MDB_NODUPDATA - enter the new key/data pair only if it does not\n\t\talready appear in the database. This flag may only be specified\n\t\tif the database was opened with #MDB_DUPSORT. The function will\n\t\treturn #MDB_KEYEXIST if the key/data pair already appears in the\n\t\tdatabase.\n\t&lt;li&gt;#MDB_NOOVERWRITE - enter the new key/data pair only if the key\n\t\tdoes not already appear in the database. The function will return\n\t\t#MDB_KEYEXIST if the key already appears in the database, even if\n\t\tthe database supports duplicates (#MDB_DUPSORT). The **data**\n\t\tparameter will be set to point to the existing item.\n\t&lt;li&gt;#MDB_RESERVE - reserve space for data of the given size, but\n\t\tdon't copy the given data. Instead, return a pointer to the\n\t\treserved space, which the caller can fill in later - before\n\t\tthe next update operation or the transaction ends. This saves\n\t\tan extra memcpy if the data is being generated later.\n\t\tLMDB does nothing else with this memory, the caller is expected\n\t\tto modify all of the space requested. This flag must not be\n\t\tspecified if the database was opened with #MDB_DUPSORT.\n\t&lt;li&gt;#MDB_APPEND - append the given key/data pair to the end of the\n\t\tdatabase. This option allows fast bulk loading when keys are\n\t\talready known to be in the correct order. Loading unsorted keys\n\t\twith this flag will cause a #MDB_KEYEXIST error.\n\t&lt;li&gt;#MDB_APPENDDUP - as above, but for sorted dup data.\n &lt;/ul&gt;\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;#MDB_MAP_FULL - the database is full, see #mdb_env_set_mapsize().\n\t&lt;li&gt;#MDB_TXN_FULL - the transaction has too many dirty pages.\n\t&lt;li&gt;EACCES - an attempt was made to write in a read-only transaction.\n\t&lt;li&gt;EINVAL - an invalid parameter was specified.\n &lt;/ul&gt;"</span>]
<a href=#388 id=388 data-nosnippet>388</a>    </span><span class="kw">pub fn </span>mdb_put(
<a href=#389 id=389 data-nosnippet>389</a>        txn: <span class="kw-2">*mut </span>MDB_txn,
<a href=#390 id=390 data-nosnippet>390</a>        dbi: MDB_dbi,
<a href=#391 id=391 data-nosnippet>391</a>        key: <span class="kw-2">*mut </span>MDB_val,
<a href=#392 id=392 data-nosnippet>392</a>        data: <span class="kw-2">*mut </span>MDB_val,
<a href=#393 id=393 data-nosnippet>393</a>        flags: ::libc::c_uint,
<a href=#394 id=394 data-nosnippet>394</a>    ) -&gt; ::libc::c_int;
<a href=#395 id=395 data-nosnippet>395</a>}
<a href=#396 id=396 data-nosnippet>396</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#397 id=397 data-nosnippet>397</a>    <span class="attr">#[doc = <span class="string">"Delete items from a database.\n\n This function removes key/data pairs from the database.\n If the database does not support sorted duplicate data items\n (#MDB_DUPSORT) the data parameter is ignored.\n If the database supports sorted duplicates and the data parameter\n is NULL, all of the duplicate data items for the key will be\n deleted. Otherwise, if the data parameter is non-NULL\n only the matching data item will be deleted.\n This function will return #MDB_NOTFOUND if the specified key/data\n pair is not in the database.\n # Arguments\n\n* `txn` (direction in) - A transaction handle returned by #mdb_txn_begin()\n * `dbi` (direction in) - A database handle returned by #mdb_dbi_open()\n * `key` (direction in) - The key to delete from the database\n * `data` (direction in) - The data to delete\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;EACCES - an attempt was made to write in a read-only transaction.\n\t&lt;li&gt;EINVAL - an invalid parameter was specified.\n &lt;/ul&gt;"</span>]
<a href=#398 id=398 data-nosnippet>398</a>    </span><span class="kw">pub fn </span>mdb_del(
<a href=#399 id=399 data-nosnippet>399</a>        txn: <span class="kw-2">*mut </span>MDB_txn,
<a href=#400 id=400 data-nosnippet>400</a>        dbi: MDB_dbi,
<a href=#401 id=401 data-nosnippet>401</a>        key: <span class="kw-2">*mut </span>MDB_val,
<a href=#402 id=402 data-nosnippet>402</a>        data: <span class="kw-2">*mut </span>MDB_val,
<a href=#403 id=403 data-nosnippet>403</a>    ) -&gt; ::libc::c_int;
<a href=#404 id=404 data-nosnippet>404</a>}
<a href=#405 id=405 data-nosnippet>405</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#406 id=406 data-nosnippet>406</a>    <span class="attr">#[doc = <span class="string">"Create a cursor handle.\n\n A cursor is associated with a specific transaction and database.\n A cursor cannot be used when its database handle is closed. Nor\n when its transaction has ended, except with #mdb_cursor_renew().\n It can be discarded with #mdb_cursor_close().\n A cursor in a write-transaction can be closed before its transaction\n ends, and will otherwise be closed when its transaction ends.\n A cursor in a read-only transaction must be closed explicitly, before\n or after its transaction ends. It can be reused with\n #mdb_cursor_renew() before finally closing it.\n &gt; **Note:** Earlier documentation said that cursors in every transaction\n were closed when the transaction committed or aborted.\n # Arguments\n\n* `txn` (direction in) - A transaction handle returned by #mdb_txn_begin()\n * `dbi` (direction in) - A database handle returned by #mdb_dbi_open()\n * `cursor` (direction out) - Address where the new #MDB_cursor handle will be stored\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;EINVAL - an invalid parameter was specified.\n &lt;/ul&gt;"</span>]
<a href=#407 id=407 data-nosnippet>407</a>    </span><span class="kw">pub fn </span>mdb_cursor_open(
<a href=#408 id=408 data-nosnippet>408</a>        txn: <span class="kw-2">*mut </span>MDB_txn,
<a href=#409 id=409 data-nosnippet>409</a>        dbi: MDB_dbi,
<a href=#410 id=410 data-nosnippet>410</a>        cursor: <span class="kw-2">*mut *mut </span>MDB_cursor,
<a href=#411 id=411 data-nosnippet>411</a>    ) -&gt; ::libc::c_int;
<a href=#412 id=412 data-nosnippet>412</a>}
<a href=#413 id=413 data-nosnippet>413</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#414 id=414 data-nosnippet>414</a>    <span class="attr">#[doc = <span class="string">"Close a cursor handle.\n\n The cursor handle will be freed and must not be used again after this call.\n Its transaction must still be live if it is a write-transaction.\n # Arguments\n\n* `cursor` (direction in) - A cursor handle returned by #mdb_cursor_open()"</span>]
<a href=#415 id=415 data-nosnippet>415</a>    </span><span class="kw">pub fn </span>mdb_cursor_close(cursor: <span class="kw-2">*mut </span>MDB_cursor);
<a href=#416 id=416 data-nosnippet>416</a>}
<a href=#417 id=417 data-nosnippet>417</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#418 id=418 data-nosnippet>418</a>    <span class="attr">#[doc = <span class="string">"Renew a cursor handle.\n\n A cursor is associated with a specific transaction and database.\n Cursors that are only used in read-only\n transactions may be re-used, to avoid unnecessary malloc/free overhead.\n The cursor may be associated with a new read-only transaction, and\n referencing the same database handle as it was created with.\n This may be done whether the previous transaction is live or dead.\n # Arguments\n\n* `txn` (direction in) - A transaction handle returned by #mdb_txn_begin()\n * `cursor` (direction in) - A cursor handle returned by #mdb_cursor_open()\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;EINVAL - an invalid parameter was specified.\n &lt;/ul&gt;"</span>]
<a href=#419 id=419 data-nosnippet>419</a>    </span><span class="kw">pub fn </span>mdb_cursor_renew(txn: <span class="kw-2">*mut </span>MDB_txn, cursor: <span class="kw-2">*mut </span>MDB_cursor) -&gt; ::libc::c_int;
<a href=#420 id=420 data-nosnippet>420</a>}
<a href=#421 id=421 data-nosnippet>421</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#422 id=422 data-nosnippet>422</a>    <span class="attr">#[doc = <span class="string">"Return the cursor's transaction handle.\n\n # Arguments\n\n* `cursor` (direction in) - A cursor handle returned by #mdb_cursor_open()"</span>]
<a href=#423 id=423 data-nosnippet>423</a>    </span><span class="kw">pub fn </span>mdb_cursor_txn(cursor: <span class="kw-2">*mut </span>MDB_cursor) -&gt; <span class="kw-2">*mut </span>MDB_txn;
<a href=#424 id=424 data-nosnippet>424</a>}
<a href=#425 id=425 data-nosnippet>425</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#426 id=426 data-nosnippet>426</a>    <span class="attr">#[doc = <span class="string">"Return the cursor's database handle.\n\n # Arguments\n\n* `cursor` (direction in) - A cursor handle returned by #mdb_cursor_open()"</span>]
<a href=#427 id=427 data-nosnippet>427</a>    </span><span class="kw">pub fn </span>mdb_cursor_dbi(cursor: <span class="kw-2">*mut </span>MDB_cursor) -&gt; MDB_dbi;
<a href=#428 id=428 data-nosnippet>428</a>}
<a href=#429 id=429 data-nosnippet>429</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#430 id=430 data-nosnippet>430</a>    <span class="attr">#[doc = <span class="string">"Retrieve by cursor.\n\n This function retrieves key/data pairs from the database. The address and length\n of the key are returned in the object to which **key** refers (except for the\n case of the #MDB_SET option, in which the **key** object is unchanged), and\n the address and length of the data are returned in the object to which **data**\n refers.\n See #mdb_get() for restrictions on using the output values.\n # Arguments\n\n* `cursor` (direction in) - A cursor handle returned by #mdb_cursor_open()\n * `key` (direction in, out) - The key for a retrieved item\n * `data` (direction in, out) - The data of a retrieved item\n * `op` (direction in) - A cursor operation #MDB_cursor_op\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;#MDB_NOTFOUND - no matching key found.\n\t&lt;li&gt;EINVAL - an invalid parameter was specified.\n &lt;/ul&gt;"</span>]
<a href=#431 id=431 data-nosnippet>431</a>    </span><span class="kw">pub fn </span>mdb_cursor_get(
<a href=#432 id=432 data-nosnippet>432</a>        cursor: <span class="kw-2">*mut </span>MDB_cursor,
<a href=#433 id=433 data-nosnippet>433</a>        key: <span class="kw-2">*mut </span>MDB_val,
<a href=#434 id=434 data-nosnippet>434</a>        data: <span class="kw-2">*mut </span>MDB_val,
<a href=#435 id=435 data-nosnippet>435</a>        op: MDB_cursor_op,
<a href=#436 id=436 data-nosnippet>436</a>    ) -&gt; ::libc::c_int;
<a href=#437 id=437 data-nosnippet>437</a>}
<a href=#438 id=438 data-nosnippet>438</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#439 id=439 data-nosnippet>439</a>    <span class="attr">#[doc = <span class="string">"Store by cursor.\n\n This function stores key/data pairs into the database.\n The cursor is positioned at the new item, or on failure usually near it.\n &gt; **Note:** Earlier documentation incorrectly said errors would leave the\n state of the cursor unchanged.\n # Arguments\n\n* `cursor` (direction in) - A cursor handle returned by #mdb_cursor_open()\n * `key` (direction in) - The key operated on.\n * `data` (direction in) - The data operated on.\n * `flags` (direction in) - Options for this operation. This parameter\n must be set to 0 or one of the values described here.\n &lt;ul&gt;\n\t&lt;li&gt;#MDB_CURRENT - replace the item at the current cursor position.\n\t\tThe **key** parameter must still be provided, and must match it.\n\t\tIf using sorted duplicates (#MDB_DUPSORT) the data item must still\n\t\tsort into the same place. This is intended to be used when the\n\t\tnew data is the same size as the old. Otherwise it will simply\n\t\tperform a delete of the old record followed by an insert.\n\t&lt;li&gt;#MDB_NODUPDATA - enter the new key/data pair only if it does not\n\t\talready appear in the database. This flag may only be specified\n\t\tif the database was opened with #MDB_DUPSORT. The function will\n\t\treturn #MDB_KEYEXIST if the key/data pair already appears in the\n\t\tdatabase.\n\t&lt;li&gt;#MDB_NOOVERWRITE - enter the new key/data pair only if the key\n\t\tdoes not already appear in the database. The function will return\n\t\t#MDB_KEYEXIST if the key already appears in the database, even if\n\t\tthe database supports duplicates (#MDB_DUPSORT).\n\t&lt;li&gt;#MDB_RESERVE - reserve space for data of the given size, but\n\t\tdon't copy the given data. Instead, return a pointer to the\n\t\treserved space, which the caller can fill in later - before\n\t\tthe next update operation or the transaction ends. This saves\n\t\tan extra memcpy if the data is being generated later. This flag\n\t\tmust not be specified if the database was opened with #MDB_DUPSORT.\n\t&lt;li&gt;#MDB_APPEND - append the given key/data pair to the end of the\n\t\tdatabase. No key comparisons are performed. This option allows\n\t\tfast bulk loading when keys are already known to be in the\n\t\tcorrect order. Loading unsorted keys with this flag will cause\n\t\ta #MDB_KEYEXIST error.\n\t&lt;li&gt;#MDB_APPENDDUP - as above, but for sorted dup data.\n\t&lt;li&gt;#MDB_MULTIPLE - store multiple contiguous data elements in a\n\t\tsingle request. This flag may only be specified if the database\n\t\twas opened with #MDB_DUPFIXED. The **data** argument must be an\n\t\tarray of two MDB_vals. The mv_size of the first MDB_val must be\n\t\tthe size of a single data element. The mv_data of the first MDB_val\n\t\tmust point to the beginning of the array of contiguous data elements.\n\t\tThe mv_size of the second MDB_val must be the count of the number\n\t\tof data elements to store. On return this field will be set to\n\t\tthe count of the number of elements actually written. The mv_data\n\t\tof the second MDB_val is unused.\n &lt;/ul&gt;\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;#MDB_MAP_FULL - the database is full, see #mdb_env_set_mapsize().\n\t&lt;li&gt;#MDB_TXN_FULL - the transaction has too many dirty pages.\n\t&lt;li&gt;EACCES - an attempt was made to write in a read-only transaction.\n\t&lt;li&gt;EINVAL - an invalid parameter was specified.\n &lt;/ul&gt;"</span>]
<a href=#440 id=440 data-nosnippet>440</a>    </span><span class="kw">pub fn </span>mdb_cursor_put(
<a href=#441 id=441 data-nosnippet>441</a>        cursor: <span class="kw-2">*mut </span>MDB_cursor,
<a href=#442 id=442 data-nosnippet>442</a>        key: <span class="kw-2">*mut </span>MDB_val,
<a href=#443 id=443 data-nosnippet>443</a>        data: <span class="kw-2">*mut </span>MDB_val,
<a href=#444 id=444 data-nosnippet>444</a>        flags: ::libc::c_uint,
<a href=#445 id=445 data-nosnippet>445</a>    ) -&gt; ::libc::c_int;
<a href=#446 id=446 data-nosnippet>446</a>}
<a href=#447 id=447 data-nosnippet>447</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#448 id=448 data-nosnippet>448</a>    <span class="attr">#[doc = <span class="string">"Delete current key/data pair\n\n This function deletes the key/data pair to which the cursor refers.\n This does not invalidate the cursor, so operations such as MDB_NEXT\n can still be used on it.\n Both MDB_NEXT and MDB_GET_CURRENT will return the same record after\n this operation.\n # Arguments\n\n* `cursor` (direction in) - A cursor handle returned by #mdb_cursor_open()\n * `flags` (direction in) - Options for this operation. This parameter\n must be set to 0 or one of the values described here.\n &lt;ul&gt;\n\t&lt;li&gt;#MDB_NODUPDATA - delete all of the data items for the current key.\n\t\tThis flag may only be specified if the database was opened with #MDB_DUPSORT.\n &lt;/ul&gt;\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;EACCES - an attempt was made to write in a read-only transaction.\n\t&lt;li&gt;EINVAL - an invalid parameter was specified.\n &lt;/ul&gt;"</span>]
<a href=#449 id=449 data-nosnippet>449</a>    </span><span class="kw">pub fn </span>mdb_cursor_del(cursor: <span class="kw-2">*mut </span>MDB_cursor, flags: ::libc::c_uint) -&gt; ::libc::c_int;
<a href=#450 id=450 data-nosnippet>450</a>}
<a href=#451 id=451 data-nosnippet>451</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#452 id=452 data-nosnippet>452</a>    <span class="attr">#[doc = <span class="string">"Return count of duplicates for current key.\n\n This call is only valid on databases that support sorted duplicate\n data items #MDB_DUPSORT.\n # Arguments\n\n* `cursor` (direction in) - A cursor handle returned by #mdb_cursor_open()\n * `countp` (direction out) - Address where the count will be stored\n # Returns\n\nA non-zero error value on failure and 0 on success. Some possible\n errors are:\n &lt;ul&gt;\n\t&lt;li&gt;EINVAL - cursor is not initialized, or an invalid parameter was specified.\n &lt;/ul&gt;"</span>]
<a href=#453 id=453 data-nosnippet>453</a>    </span><span class="kw">pub fn </span>mdb_cursor_count(cursor: <span class="kw-2">*mut </span>MDB_cursor, countp: <span class="kw-2">*mut </span>mdb_size_t) -&gt; ::libc::c_int;
<a href=#454 id=454 data-nosnippet>454</a>}
<a href=#455 id=455 data-nosnippet>455</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#456 id=456 data-nosnippet>456</a>    <span class="attr">#[doc = <span class="string">"Compare two data items according to a particular database.\n\n This returns a comparison as if the two data items were keys in the\n specified database.\n # Arguments\n\n* `txn` (direction in) - A transaction handle returned by #mdb_txn_begin()\n * `dbi` (direction in) - A database handle returned by #mdb_dbi_open()\n * `a` (direction in) - The first item to compare\n * `b` (direction in) - The second item to compare\n # Returns\n\n&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b"</span>]
<a href=#457 id=457 data-nosnippet>457</a>    </span><span class="kw">pub fn </span>mdb_cmp(
<a href=#458 id=458 data-nosnippet>458</a>        txn: <span class="kw-2">*mut </span>MDB_txn,
<a href=#459 id=459 data-nosnippet>459</a>        dbi: MDB_dbi,
<a href=#460 id=460 data-nosnippet>460</a>        a: <span class="kw-2">*const </span>MDB_val,
<a href=#461 id=461 data-nosnippet>461</a>        b: <span class="kw-2">*const </span>MDB_val,
<a href=#462 id=462 data-nosnippet>462</a>    ) -&gt; ::libc::c_int;
<a href=#463 id=463 data-nosnippet>463</a>}
<a href=#464 id=464 data-nosnippet>464</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#465 id=465 data-nosnippet>465</a>    <span class="attr">#[doc = <span class="string">"Compare two data items according to a particular database.\n\n This returns a comparison as if the two items were data items of\n the specified database. The database must have the #MDB_DUPSORT flag.\n # Arguments\n\n* `txn` (direction in) - A transaction handle returned by #mdb_txn_begin()\n * `dbi` (direction in) - A database handle returned by #mdb_dbi_open()\n * `a` (direction in) - The first item to compare\n * `b` (direction in) - The second item to compare\n # Returns\n\n&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b"</span>]
<a href=#466 id=466 data-nosnippet>466</a>    </span><span class="kw">pub fn </span>mdb_dcmp(
<a href=#467 id=467 data-nosnippet>467</a>        txn: <span class="kw-2">*mut </span>MDB_txn,
<a href=#468 id=468 data-nosnippet>468</a>        dbi: MDB_dbi,
<a href=#469 id=469 data-nosnippet>469</a>        a: <span class="kw-2">*const </span>MDB_val,
<a href=#470 id=470 data-nosnippet>470</a>        b: <span class="kw-2">*const </span>MDB_val,
<a href=#471 id=471 data-nosnippet>471</a>    ) -&gt; ::libc::c_int;
<a href=#472 id=472 data-nosnippet>472</a>}
<a href=#473 id=473 data-nosnippet>473</a><span class="attr">#[doc = <span class="string">"A callback function used to print a message from the library.\n\n # Arguments\n\n* `msg` (direction in) - The string to be printed.\n * `ctx` (direction in) - An arbitrary context pointer for the callback.\n # Returns\n\n&lt; 0 on failure, &gt;= 0 on success."</span>]
<a href=#474 id=474 data-nosnippet>474</a></span><span class="kw">pub type </span>MDB_msg_func = ::std::option::Option&lt;
<a href=#475 id=475 data-nosnippet>475</a>    <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(msg: <span class="kw-2">*const </span>::libc::c_char, ctx: <span class="kw-2">*mut </span>::libc::c_void) -&gt; ::libc::c_int,
<a href=#476 id=476 data-nosnippet>476</a>&gt;;
<a href=#477 id=477 data-nosnippet>477</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#478 id=478 data-nosnippet>478</a>    <span class="attr">#[doc = <span class="string">"Dump the entries in the reader lock table.\n\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create()\n * `func` (direction in) - A #MDB_msg_func function\n * `ctx` (direction in) - Anything the message function needs\n # Returns\n\n&lt; 0 on failure, &gt;= 0 on success."</span>]
<a href=#479 id=479 data-nosnippet>479</a>    </span><span class="kw">pub fn </span>mdb_reader_list(
<a href=#480 id=480 data-nosnippet>480</a>        env: <span class="kw-2">*mut </span>MDB_env,
<a href=#481 id=481 data-nosnippet>481</a>        func: MDB_msg_func,
<a href=#482 id=482 data-nosnippet>482</a>        ctx: <span class="kw-2">*mut </span>::libc::c_void,
<a href=#483 id=483 data-nosnippet>483</a>    ) -&gt; ::libc::c_int;
<a href=#484 id=484 data-nosnippet>484</a>}
<a href=#485 id=485 data-nosnippet>485</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#486 id=486 data-nosnippet>486</a>    <span class="attr">#[doc = <span class="string">"Check for stale entries in the reader lock table.\n\n # Arguments\n\n* `env` (direction in) - An environment handle returned by #mdb_env_create()\n * `dead` (direction out) - Number of stale slots that were cleared\n # Returns\n\n0 on success, non-zero on failure."</span>]
<a href=#487 id=487 data-nosnippet>487</a>    </span><span class="kw">pub fn </span>mdb_reader_check(env: <span class="kw-2">*mut </span>MDB_env, dead: <span class="kw-2">*mut </span>::libc::c_int) -&gt; ::libc::c_int;
<a href=#488 id=488 data-nosnippet>488</a>}</code></pre></div></section></main></body></html>