<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="rbert"><title>rbert - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="rbert" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0 (17067e9ac 2025-05-09)" data-channel="1.87.0" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../static.files/storage-82c7156e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../rbert/index.html">rbert</a><span class="version">0.4.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#rbert" title="rbert">rbert</a><ul><li><a href="#usage" title="Usage">Usage</a></li></ul></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>rbert</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/rbert/lib.rs.html#1-418">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="rbert"><a class="doc-anchor" href="#rbert">§</a>rbert</h2>
<p>A Rust wrapper for <a href="https://arxiv.org/abs/1908.10084">bert sentence transformers</a> implemented in <a href="https://github.com/huggingface/candle">Candle</a></p>
<h3 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>kalosm_language_model::Embedder;
<span class="kw">use </span>rbert::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() -&gt; anyhow::Result&lt;()&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>bert = Bert::new().<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="kw">let </span>sentences = [
        <span class="string">"Cats are cool"</span>,
        <span class="string">"The geopolitical situation is dire"</span>,
        <span class="string">"Pets are great"</span>,
        <span class="string">"Napoleon was a tyrant"</span>,
        <span class="string">"Napoleon was a great general"</span>,
    ];
    <span class="kw">let </span>embeddings = bert.embed_batch(sentences).<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="macro">println!</span>(<span class="string">"embeddings {:?}"</span>, embeddings);

    <span class="comment">// Find the cosine similarity between the first two sentences
    </span><span class="kw">let </span><span class="kw-2">mut </span>similarities = <span class="macro">vec!</span>[];
    <span class="kw">let </span>n_sentences = sentences.len();
    <span class="kw">for </span>(i, e_i) <span class="kw">in </span>embeddings.iter().enumerate() {
        <span class="kw">for </span>j <span class="kw">in </span>(i + <span class="number">1</span>)..n_sentences {
            <span class="kw">let </span>e_j = embeddings.get(j).unwrap();
            <span class="kw">let </span>cosine_similarity = e_j.cosine_similarity(e_i);
            similarities.push((cosine_similarity, i, j))
        }
    }
    similarities.sort_by(|u, v| v.<span class="number">0</span>.total_cmp(<span class="kw-2">&amp;</span>u.<span class="number">0</span>));
    <span class="kw">for </span><span class="kw-2">&amp;</span>(score, i, j) <span class="kw">in </span>similarities.iter() {
        <span class="macro">println!</span>(<span class="string">"score: {score:.2} '{}' '{}'"</span>, sentences[i], sentences[j])
    }

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.Bert"><code>pub use crate::<a class="struct" href="struct.Bert.html" title="struct rbert::Bert">Bert</a>;</code></dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Bert.html" title="struct rbert::Bert">Bert</a></dt><dd>A bert embedding model. The main interface for this model is <a href="trait.EmbedderExt.html" title="trait rbert::EmbedderExt"><code>EmbedderExt</code></a>.</dd><dt><a class="struct" href="struct.BertBuilder.html" title="struct rbert::BertBuilder">Bert<wbr>Builder</a></dt><dd>A builder for a <a href="struct.Bert.html" title="struct rbert::Bert"><code>Bert</code></a> model</dd><dt><a class="struct" href="struct.BertModel.html" title="struct rbert::BertModel">Bert<wbr>Model</a></dt><dd>A raw synchronous Bert model. You should generally use the <a href="struct.Bert.html" title="struct rbert::Bert"><code>super::Bert</code></a> instead.</dd><dt><a class="struct" href="struct.BertSource.html" title="struct rbert::BertSource">Bert<wbr>Source</a></dt><dd>A the source of a <a href="struct.Bert.html" title="struct rbert::Bert"><code>crate::Bert</code></a> model</dd><dt><a class="struct" href="struct.Config.html" title="struct rbert::Config">Config</a></dt><dd>The configuration of a <a href="struct.BertModel.html" title="struct rbert::BertModel"><code>BertModel</code></a>.</dd><dt><a class="struct" href="struct.Embedding.html" title="struct rbert::Embedding">Embedding</a></dt><dd>Embeddings</dd><dt><a class="struct" href="struct.EmbeddingInput.html" title="struct rbert::EmbeddingInput">Embedding<wbr>Input</a></dt><dd>The input to an embedding model. This includes the text to be embedded and the type of embedding to output.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.BertError.html" title="enum rbert::BertError">Bert<wbr>Error</a></dt><dd>An error that can occur when running a Bert model.</dd><dt><a class="enum" href="enum.BertLoadingError.html" title="enum rbert::BertLoadingError">Bert<wbr>Loading<wbr>Error</a></dt><dd>An error that can occur when loading a Bert model.</dd><dt><a class="enum" href="enum.EmbeddingVariant.html" title="enum rbert::EmbeddingVariant">Embedding<wbr>Variant</a></dt><dd>The type of embedding the model should output. For models that output different embeddings for queries and documents, this</dd><dt><a class="enum" href="enum.Pooling.html" title="enum rbert::Pooling">Pooling</a></dt><dd>The pooling strategy to use when embedding text.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Embedder.html" title="trait rbert::Embedder">Embedder</a></dt><dd>A model that can be used to embed text. This trait is generic over the vector space that the model uses to help keep track of what embeddings came from which model.</dd><dt><a class="trait" href="trait.EmbedderCacheExt.html" title="trait rbert::EmbedderCacheExt">Embedder<wbr>Cache<wbr>Ext</a></dt><dd>An extension trait for <a href="trait.Embedder.html" title="trait rbert::Embedder"><code>Embedder</code></a> that allows for caching embeddings.</dd><dt><a class="trait" href="trait.EmbedderExt.html" title="trait rbert::EmbedderExt">Embedder<wbr>Ext</a></dt><dd>An extension trait for <a href="trait.Embedder.html" title="trait rbert::Embedder"><code>Embedder</code></a> with helper methods for iterators, and types that can be converted into a string.</dd><dt><a class="trait" href="trait.ModelBuilder.html" title="trait rbert::ModelBuilder">Model<wbr>Builder</a></dt><dd>A builder that can create a model asynchronously.</dd></dl></section></div></main></body></html>